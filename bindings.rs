/* automatically generated by rust-bindgen 0.59.2 */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage> {
        storage: Storage,
    }
    impl<Storage> __BindgenBitfieldUnit<Storage> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage }
        }
    }
    impl<Storage> __BindgenBitfieldUnit<Storage>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[allow(unused_imports)]
    use self::super::root;
    pub const AK_SIMD_ALIGNMENT: u32 = 16;
    pub const AK_BUFFER_ALIGNMENT: u32 = 16;
    pub const AK_UINT_MAX: u32 = 4294967295;
    pub const AK_MAX_PATH: u32 = 260;
    pub const AK_BANK_PLATFORM_DATA_ALIGNMENT: u32 = 16;
    pub const AK_OSCHAR_FMT: &[u8; 3usize] = b"%s\0";
    pub const AKCURVEINTERPOLATION_NUM_STORAGE_BIT: u32 = 5;
    pub const AK_MAX_LANGUAGE_NAME_SIZE: u32 = 32;
    pub const AKCOMPANYID_PLUGINDEV_MIN: u32 = 64;
    pub const AKCOMPANYID_PLUGINDEV_MAX: u32 = 255;
    pub const AKCOMPANYID_AUDIOKINETIC: u32 = 0;
    pub const AKCOMPANYID_AUDIOKINETIC_EXTERNAL: u32 = 1;
    pub const AKCOMPANYID_MCDSP: u32 = 256;
    pub const AKCOMPANYID_WAVEARTS: u32 = 257;
    pub const AKCOMPANYID_PHONETICARTS: u32 = 258;
    pub const AKCOMPANYID_IZOTOPE: u32 = 259;
    pub const AKCOMPANYID_CRANKCASEAUDIO: u32 = 261;
    pub const AKCOMPANYID_IOSONO: u32 = 262;
    pub const AKCOMPANYID_AUROTECHNOLOGIES: u32 = 263;
    pub const AKCOMPANYID_DOLBY: u32 = 264;
    pub const AKCOMPANYID_TWOBIGEARS: u32 = 265;
    pub const AKCOMPANYID_OCULUS: u32 = 266;
    pub const AKCOMPANYID_BLUERIPPLESOUND: u32 = 267;
    pub const AKCOMPANYID_ENZIEN: u32 = 268;
    pub const AKCOMPANYID_KROTOS: u32 = 269;
    pub const AKCOMPANYID_NURULIZE: u32 = 270;
    pub const AKCOMPANYID_SUPERPOWERED: u32 = 271;
    pub const AKCOMPANYID_GOOGLE: u32 = 272;
    pub const AKCOMPANYID_VISISONICS: u32 = 277;
    pub const AKCODECID_BANK: u32 = 0;
    pub const AKCODECID_PCM: u32 = 1;
    pub const AKCODECID_ADPCM: u32 = 2;
    pub const AKCODECID_XMA: u32 = 3;
    pub const AKCODECID_VORBIS: u32 = 4;
    pub const AKCODECID_WIIADPCM: u32 = 5;
    pub const AKCODECID_PCMEX: u32 = 7;
    pub const AKCODECID_EXTERNAL_SOURCE: u32 = 8;
    pub const AKCODECID_XWMA: u32 = 9;
    pub const AKCODECID_AAC: u32 = 10;
    pub const AKCODECID_FILE_PACKAGE: u32 = 11;
    pub const AKCODECID_ATRAC9: u32 = 12;
    pub const AKCODECID_VAG: u32 = 13;
    pub const AKCODECID_PROFILERCAPTURE: u32 = 14;
    pub const AKCODECID_ANALYSISFILE: u32 = 15;
    pub const AKCODECID_MIDI: u32 = 16;
    pub const AKCODECID_OPUSNX: u32 = 17;
    pub const AKCODECID_CAF: u32 = 18;
    pub const AKCODECID_AKOPUS: u32 = 19;
    pub const AKCODECID_AKOPUS_WEM: u32 = 20;
    pub const AKCODECID_MEMORYMGR_DUMP: u32 = 21;
    pub const AKPLUGINID_METER: u32 = 129;
    pub const AKPLUGINID_RECORDER: u32 = 132;
    pub const AKPLUGINID_IMPACTER: u32 = 184;
    pub const AKPLUGINID_SYSTEM_OUTPUT_META: u32 = 900;
    pub const AKEXTENSIONID_SPATIALAUDIO: u32 = 800;
    pub const AKEXTENSIONID_INTERACTIVEMUSIC: u32 = 801;
    pub const AKEXTENSIONID_EVENTMGRTHREAD: u32 = 900;
    pub const AK_WAVE_FORMAT_VAG: u32 = 65531;
    pub const AK_WAVE_FORMAT_AT9: u32 = 65532;
    pub const AK_WAVE_FORMAT_VORBIS: u32 = 65535;
    pub const AK_WAVE_FORMAT_AAC: u32 = 43712;
    pub const AK_WAVE_FORMAT_OPUSNX: u32 = 12345;
    pub const AK_WAVE_FORMAT_OPUS: u32 = 12352;
    pub const AK_WAVE_FORMAT_OPUS_WEM: u32 = 12353;
    pub const AK_PANNER_NUM_STORAGE_BITS: u32 = 3;
    pub const AK_POSSOURCE_NUM_STORAGE_BITS: u32 = 3;
    pub const AK_SPAT_NUM_STORAGE_BITS: u32 = 3;
    pub const AK_MAX_BITS_METERING_FLAGS: u32 = 5;
    pub const AK_COMM_DEFAULT_DISCOVERY_PORT: u32 = 24024;
    pub const AK_SPEAKER_FRONT_LEFT: u32 = 1;
    pub const AK_SPEAKER_FRONT_RIGHT: u32 = 2;
    pub const AK_SPEAKER_FRONT_CENTER: u32 = 4;
    pub const AK_SPEAKER_LOW_FREQUENCY: u32 = 8;
    pub const AK_SPEAKER_BACK_LEFT: u32 = 16;
    pub const AK_SPEAKER_BACK_RIGHT: u32 = 32;
    pub const AK_SPEAKER_BACK_CENTER: u32 = 256;
    pub const AK_SPEAKER_SIDE_LEFT: u32 = 512;
    pub const AK_SPEAKER_SIDE_RIGHT: u32 = 1024;
    pub const AK_SPEAKER_TOP: u32 = 2048;
    pub const AK_SPEAKER_HEIGHT_FRONT_LEFT: u32 = 4096;
    pub const AK_SPEAKER_HEIGHT_FRONT_CENTER: u32 = 8192;
    pub const AK_SPEAKER_HEIGHT_FRONT_RIGHT: u32 = 16384;
    pub const AK_SPEAKER_HEIGHT_BACK_LEFT: u32 = 32768;
    pub const AK_SPEAKER_HEIGHT_BACK_CENTER: u32 = 65536;
    pub const AK_SPEAKER_HEIGHT_BACK_RIGHT: u32 = 131072;
    pub const AK_SPEAKER_SETUP_MONO: u32 = 4;
    pub const AK_SPEAKER_SETUP_0POINT1: u32 = 8;
    pub const AK_SPEAKER_SETUP_1POINT1: u32 = 12;
    pub const AK_SPEAKER_SETUP_STEREO: u32 = 3;
    pub const AK_SPEAKER_SETUP_2POINT1: u32 = 11;
    pub const AK_SPEAKER_SETUP_3STEREO: u32 = 7;
    pub const AK_SPEAKER_SETUP_3POINT1: u32 = 15;
    pub const AK_SPEAKER_SETUP_4: u32 = 1539;
    pub const AK_SPEAKER_SETUP_4POINT1: u32 = 1547;
    pub const AK_SPEAKER_SETUP_5: u32 = 1543;
    pub const AK_SPEAKER_SETUP_5POINT1: u32 = 1551;
    pub const AK_SPEAKER_SETUP_6: u32 = 1587;
    pub const AK_SPEAKER_SETUP_6POINT1: u32 = 1595;
    pub const AK_SPEAKER_SETUP_7: u32 = 1591;
    pub const AK_SPEAKER_SETUP_7POINT1: u32 = 1599;
    pub const AK_SPEAKER_SETUP_SURROUND: u32 = 259;
    pub const AK_SPEAKER_SETUP_DPL2: u32 = 1539;
    pub const AK_SPEAKER_SETUP_HEIGHT_2: u32 = 20480;
    pub const AK_SPEAKER_SETUP_HEIGHT_4: u32 = 184320;
    pub const AK_SPEAKER_SETUP_HEIGHT_5: u32 = 192512;
    pub const AK_SPEAKER_SETUP_HEIGHT_ALL: u32 = 258048;
    pub const AK_SPEAKER_SETUP_HEIGHT_4_TOP: u32 = 186368;
    pub const AK_SPEAKER_SETUP_HEIGHT_5_TOP: u32 = 194560;
    pub const AK_SPEAKER_SETUP_AURO_222: u32 = 22019;
    pub const AK_SPEAKER_SETUP_AURO_8: u32 = 185859;
    pub const AK_SPEAKER_SETUP_AURO_9: u32 = 185863;
    pub const AK_SPEAKER_SETUP_AURO_9POINT1: u32 = 185871;
    pub const AK_SPEAKER_SETUP_AURO_10: u32 = 187911;
    pub const AK_SPEAKER_SETUP_AURO_10POINT1: u32 = 187919;
    pub const AK_SPEAKER_SETUP_AURO_11: u32 = 196103;
    pub const AK_SPEAKER_SETUP_AURO_11POINT1: u32 = 196111;
    pub const AK_SPEAKER_SETUP_AURO_11_740: u32 = 185911;
    pub const AK_SPEAKER_SETUP_AURO_11POINT1_740: u32 = 185919;
    pub const AK_SPEAKER_SETUP_AURO_13_751: u32 = 196151;
    pub const AK_SPEAKER_SETUP_AURO_13POINT1_751: u32 = 196159;
    pub const AK_SPEAKER_SETUP_DOLBY_5_0_2: u32 = 22023;
    pub const AK_SPEAKER_SETUP_DOLBY_5_1_2: u32 = 22031;
    pub const AK_SPEAKER_SETUP_DOLBY_6_0_2: u32 = 22067;
    pub const AK_SPEAKER_SETUP_DOLBY_6_1_2: u32 = 22075;
    pub const AK_SPEAKER_SETUP_DOLBY_6_0_4: u32 = 185907;
    pub const AK_SPEAKER_SETUP_DOLBY_6_1_4: u32 = 185915;
    pub const AK_SPEAKER_SETUP_DOLBY_7_0_2: u32 = 22071;
    pub const AK_SPEAKER_SETUP_DOLBY_7_1_2: u32 = 22079;
    pub const AK_SPEAKER_SETUP_DOLBY_7_0_4: u32 = 185911;
    pub const AK_SPEAKER_SETUP_DOLBY_7_1_4: u32 = 185919;
    pub const AK_SPEAKER_SETUP_ALL_SPEAKERS: u32 = 261951;
    pub const AK_IDX_SETUP_FRONT_LEFT: u32 = 0;
    pub const AK_IDX_SETUP_FRONT_RIGHT: u32 = 1;
    pub const AK_IDX_SETUP_CENTER: u32 = 2;
    pub const AK_IDX_SETUP_NOCENTER_BACK_LEFT: u32 = 2;
    pub const AK_IDX_SETUP_NOCENTER_BACK_RIGHT: u32 = 3;
    pub const AK_IDX_SETUP_NOCENTER_SIDE_LEFT: u32 = 4;
    pub const AK_IDX_SETUP_NOCENTER_SIDE_RIGHT: u32 = 5;
    pub const AK_IDX_SETUP_WITHCENTER_BACK_LEFT: u32 = 3;
    pub const AK_IDX_SETUP_WITHCENTER_BACK_RIGHT: u32 = 4;
    pub const AK_IDX_SETUP_WITHCENTER_SIDE_LEFT: u32 = 5;
    pub const AK_IDX_SETUP_WITHCENTER_SIDE_RIGHT: u32 = 6;
    pub const AK_IDX_SETUP_0_LFE: u32 = 0;
    pub const AK_IDX_SETUP_1_CENTER: u32 = 0;
    pub const AK_IDX_SETUP_1_LFE: u32 = 1;
    pub const AK_IDX_SETUP_2_LEFT: u32 = 0;
    pub const AK_IDX_SETUP_2_RIGHT: u32 = 1;
    pub const AK_IDX_SETUP_2_LFE: u32 = 2;
    pub const AK_IDX_SETUP_3_LEFT: u32 = 0;
    pub const AK_IDX_SETUP_3_RIGHT: u32 = 1;
    pub const AK_IDX_SETUP_3_CENTER: u32 = 2;
    pub const AK_IDX_SETUP_3_LFE: u32 = 3;
    pub const AK_IDX_SETUP_4_FRONTLEFT: u32 = 0;
    pub const AK_IDX_SETUP_4_FRONTRIGHT: u32 = 1;
    pub const AK_IDX_SETUP_4_REARLEFT: u32 = 2;
    pub const AK_IDX_SETUP_4_REARRIGHT: u32 = 3;
    pub const AK_IDX_SETUP_4_LFE: u32 = 4;
    pub const AK_IDX_SETUP_5_FRONTLEFT: u32 = 0;
    pub const AK_IDX_SETUP_5_FRONTRIGHT: u32 = 1;
    pub const AK_IDX_SETUP_5_CENTER: u32 = 2;
    pub const AK_IDX_SETUP_5_REARLEFT: u32 = 3;
    pub const AK_IDX_SETUP_5_REARRIGHT: u32 = 4;
    pub const AK_IDX_SETUP_5_LFE: u32 = 5;
    pub const AK_IDX_SETUP_6_FRONTLEFT: u32 = 0;
    pub const AK_IDX_SETUP_6_FRONTRIGHT: u32 = 1;
    pub const AK_IDX_SETUP_6_REARLEFT: u32 = 2;
    pub const AK_IDX_SETUP_6_REARRIGHT: u32 = 3;
    pub const AK_IDX_SETUP_6_SIDELEFT: u32 = 4;
    pub const AK_IDX_SETUP_6_SIDERIGHT: u32 = 5;
    pub const AK_IDX_SETUP_6_LFE: u32 = 6;
    pub const AK_IDX_SETUP_7_FRONTLEFT: u32 = 0;
    pub const AK_IDX_SETUP_7_FRONTRIGHT: u32 = 1;
    pub const AK_IDX_SETUP_7_CENTER: u32 = 2;
    pub const AK_IDX_SETUP_7_REARLEFT: u32 = 3;
    pub const AK_IDX_SETUP_7_REARRIGHT: u32 = 4;
    pub const AK_IDX_SETUP_7_SIDELEFT: u32 = 5;
    pub const AK_IDX_SETUP_7_SIDERIGHT: u32 = 6;
    pub const AK_IDX_SETUP_7_LFE: u32 = 7;
    pub const AK_SPEAKER_SETUP_0_1: u32 = 8;
    pub const AK_SPEAKER_SETUP_1_0_CENTER: u32 = 4;
    pub const AK_SPEAKER_SETUP_1_1_CENTER: u32 = 12;
    pub const AK_SPEAKER_SETUP_2_0: u32 = 3;
    pub const AK_SPEAKER_SETUP_2_1: u32 = 11;
    pub const AK_SPEAKER_SETUP_3_0: u32 = 7;
    pub const AK_SPEAKER_SETUP_3_1: u32 = 15;
    pub const AK_SPEAKER_SETUP_FRONT: u32 = 7;
    pub const AK_SPEAKER_SETUP_4_0: u32 = 1539;
    pub const AK_SPEAKER_SETUP_4_1: u32 = 1547;
    pub const AK_SPEAKER_SETUP_5_0: u32 = 1543;
    pub const AK_SPEAKER_SETUP_5_1: u32 = 1551;
    pub const AK_SPEAKER_SETUP_6_0: u32 = 1587;
    pub const AK_SPEAKER_SETUP_6_1: u32 = 1595;
    pub const AK_SPEAKER_SETUP_7_0: u32 = 1591;
    pub const AK_SPEAKER_SETUP_7_1: u32 = 1599;
    pub const AK_SPEAKER_SETUP_DEFAULT_PLANE: u32 = 1599;
    pub const AK_SUPPORTED_STANDARD_CHANNEL_MASK: u32 = 261951;
    pub const AK_STANDARD_MAX_NUM_CHANNELS: u32 = 8;
    pub const AK_MAX_AMBISONICS_ORDER: u32 = 5;
    pub const AK_LIBRARY_PREFIX: &[u8; 1usize] = b"\0";
    pub const AK_DYNAMIC_LIBRARY_EXTENSION: &[u8; 7usize] = b".dylib\0";
    pub const AK_POSIX_NO_ERR: u32 = 0;
    pub const AK_RETURN_THREAD_OK: u32 = 0;
    pub const AK_RETURN_THREAD_ERROR: u32 = 1;
    pub const AK_DEFAULT_STACK_SIZE: u32 = 131072;
    pub const AK_THREAD_DEFAULT_SCHED_POLICY: u32 = 4;
    pub const AK_THREAD_AFFINITY_DEFAULT: u32 = 65535;
    pub const AK_NULL_THREAD: u32 = 0;
    pub const AK_INFINITE: u32 = 4294967295;
    pub const AK_PATH_SEPARATOR: &[u8; 2usize] = b"/\0";
    pub const AK_HASH_SIZE_VERY_SMALL: u32 = 11;
    pub const AK_DEFAULT_LISTENER_POSITION_X: f64 = 0.0;
    pub const AK_DEFAULT_LISTENER_POSITION_Y: f64 = 0.0;
    pub const AK_DEFAULT_LISTENER_POSITION_Z: f64 = 0.0;
    pub const AK_DEFAULT_LISTENER_FRONT_X: f64 = 0.0;
    pub const AK_DEFAULT_LISTENER_FRONT_Y: f64 = 0.0;
    pub const AK_DEFAULT_LISTENER_FRONT_Z: f64 = 1.0;
    pub const AK_DEFAULT_TOP_X: f64 = 0.0;
    pub const AK_DEFAULT_TOP_Y: f64 = 1.0;
    pub const AK_DEFAULT_TOP_Z: f64 = 0.0;
    pub const AK_MIDI_EVENT_TYPE_INVALID: u32 = 0;
    pub const AK_MIDI_EVENT_TYPE_NOTE_OFF: u32 = 128;
    pub const AK_MIDI_EVENT_TYPE_NOTE_ON: u32 = 144;
    pub const AK_MIDI_EVENT_TYPE_NOTE_AFTERTOUCH: u32 = 160;
    pub const AK_MIDI_EVENT_TYPE_CONTROLLER: u32 = 176;
    pub const AK_MIDI_EVENT_TYPE_PROGRAM_CHANGE: u32 = 192;
    pub const AK_MIDI_EVENT_TYPE_CHANNEL_AFTERTOUCH: u32 = 208;
    pub const AK_MIDI_EVENT_TYPE_PITCH_BEND: u32 = 224;
    pub const AK_MIDI_EVENT_TYPE_SYSEX: u32 = 240;
    pub const AK_MIDI_EVENT_TYPE_ESCAPE: u32 = 247;
    pub const AK_MIDI_EVENT_TYPE_WWISE_CMD: u32 = 254;
    pub const AK_MIDI_EVENT_TYPE_META: u32 = 255;
    pub const AK_MIDI_CC_BANK_SELECT_COARSE: u32 = 0;
    pub const AK_MIDI_CC_MOD_WHEEL_COARSE: u32 = 1;
    pub const AK_MIDI_CC_BREATH_CTRL_COARSE: u32 = 2;
    pub const AK_MIDI_CC_CTRL_3_COARSE: u32 = 3;
    pub const AK_MIDI_CC_FOOT_PEDAL_COARSE: u32 = 4;
    pub const AK_MIDI_CC_PORTAMENTO_COARSE: u32 = 5;
    pub const AK_MIDI_CC_DATA_ENTRY_COARSE: u32 = 6;
    pub const AK_MIDI_CC_VOLUME_COARSE: u32 = 7;
    pub const AK_MIDI_CC_BALANCE_COARSE: u32 = 8;
    pub const AK_MIDI_CC_CTRL_9_COARSE: u32 = 9;
    pub const AK_MIDI_CC_PAN_POSITION_COARSE: u32 = 10;
    pub const AK_MIDI_CC_EXPRESSION_COARSE: u32 = 11;
    pub const AK_MIDI_CC_EFFECT_CTRL_1_COARSE: u32 = 12;
    pub const AK_MIDI_CC_EFFECT_CTRL_2_COARSE: u32 = 13;
    pub const AK_MIDI_CC_CTRL_14_COARSE: u32 = 14;
    pub const AK_MIDI_CC_CTRL_15_COARSE: u32 = 15;
    pub const AK_MIDI_CC_GEN_SLIDER_1: u32 = 16;
    pub const AK_MIDI_CC_GEN_SLIDER_2: u32 = 17;
    pub const AK_MIDI_CC_GEN_SLIDER_3: u32 = 18;
    pub const AK_MIDI_CC_GEN_SLIDER_4: u32 = 19;
    pub const AK_MIDI_CC_CTRL_20_COARSE: u32 = 20;
    pub const AK_MIDI_CC_CTRL_21_COARSE: u32 = 21;
    pub const AK_MIDI_CC_CTRL_22_COARSE: u32 = 22;
    pub const AK_MIDI_CC_CTRL_23_COARSE: u32 = 23;
    pub const AK_MIDI_CC_CTRL_24_COARSE: u32 = 24;
    pub const AK_MIDI_CC_CTRL_25_COARSE: u32 = 25;
    pub const AK_MIDI_CC_CTRL_26_COARSE: u32 = 26;
    pub const AK_MIDI_CC_CTRL_27_COARSE: u32 = 27;
    pub const AK_MIDI_CC_CTRL_28_COARSE: u32 = 28;
    pub const AK_MIDI_CC_CTRL_29_COARSE: u32 = 29;
    pub const AK_MIDI_CC_CTRL_30_COARSE: u32 = 30;
    pub const AK_MIDI_CC_CTRL_31_COARSE: u32 = 31;
    pub const AK_MIDI_CC_BANK_SELECT_FINE: u32 = 32;
    pub const AK_MIDI_CC_MOD_WHEEL_FINE: u32 = 33;
    pub const AK_MIDI_CC_BREATH_CTRL_FINE: u32 = 34;
    pub const AK_MIDI_CC_CTRL_3_FINE: u32 = 35;
    pub const AK_MIDI_CC_FOOT_PEDAL_FINE: u32 = 36;
    pub const AK_MIDI_CC_PORTAMENTO_FINE: u32 = 37;
    pub const AK_MIDI_CC_DATA_ENTRY_FINE: u32 = 38;
    pub const AK_MIDI_CC_VOLUME_FINE: u32 = 39;
    pub const AK_MIDI_CC_BALANCE_FINE: u32 = 40;
    pub const AK_MIDI_CC_CTRL_9_FINE: u32 = 41;
    pub const AK_MIDI_CC_PAN_POSITION_FINE: u32 = 42;
    pub const AK_MIDI_CC_EXPRESSION_FINE: u32 = 43;
    pub const AK_MIDI_CC_EFFECT_CTRL_1_FINE: u32 = 44;
    pub const AK_MIDI_CC_EFFECT_CTRL_2_FINE: u32 = 45;
    pub const AK_MIDI_CC_CTRL_14_FINE: u32 = 46;
    pub const AK_MIDI_CC_CTRL_15_FINE: u32 = 47;
    pub const AK_MIDI_CC_CTRL_20_FINE: u32 = 52;
    pub const AK_MIDI_CC_CTRL_21_FINE: u32 = 53;
    pub const AK_MIDI_CC_CTRL_22_FINE: u32 = 54;
    pub const AK_MIDI_CC_CTRL_23_FINE: u32 = 55;
    pub const AK_MIDI_CC_CTRL_24_FINE: u32 = 56;
    pub const AK_MIDI_CC_CTRL_25_FINE: u32 = 57;
    pub const AK_MIDI_CC_CTRL_26_FINE: u32 = 58;
    pub const AK_MIDI_CC_CTRL_27_FINE: u32 = 59;
    pub const AK_MIDI_CC_CTRL_28_FINE: u32 = 60;
    pub const AK_MIDI_CC_CTRL_29_FINE: u32 = 61;
    pub const AK_MIDI_CC_CTRL_30_FINE: u32 = 62;
    pub const AK_MIDI_CC_CTRL_31_FINE: u32 = 63;
    pub const AK_MIDI_CC_HOLD_PEDAL: u32 = 64;
    pub const AK_MIDI_CC_PORTAMENTO_ON_OFF: u32 = 65;
    pub const AK_MIDI_CC_SUSTENUTO_PEDAL: u32 = 66;
    pub const AK_MIDI_CC_SOFT_PEDAL: u32 = 67;
    pub const AK_MIDI_CC_LEGATO_PEDAL: u32 = 68;
    pub const AK_MIDI_CC_HOLD_PEDAL_2: u32 = 69;
    pub const AK_MIDI_CC_SOUND_VARIATION: u32 = 70;
    pub const AK_MIDI_CC_SOUND_TIMBRE: u32 = 71;
    pub const AK_MIDI_CC_SOUND_RELEASE_TIME: u32 = 72;
    pub const AK_MIDI_CC_SOUND_ATTACK_TIME: u32 = 73;
    pub const AK_MIDI_CC_SOUND_BRIGHTNESS: u32 = 74;
    pub const AK_MIDI_CC_SOUND_CTRL_6: u32 = 75;
    pub const AK_MIDI_CC_SOUND_CTRL_7: u32 = 76;
    pub const AK_MIDI_CC_SOUND_CTRL_8: u32 = 77;
    pub const AK_MIDI_CC_SOUND_CTRL_9: u32 = 78;
    pub const AK_MIDI_CC_SOUND_CTRL_10: u32 = 79;
    pub const AK_MIDI_CC_GENERAL_BUTTON_1: u32 = 80;
    pub const AK_MIDI_CC_GENERAL_BUTTON_2: u32 = 81;
    pub const AK_MIDI_CC_GENERAL_BUTTON_3: u32 = 82;
    pub const AK_MIDI_CC_GENERAL_BUTTON_4: u32 = 83;
    pub const AK_MIDI_CC_REVERB_LEVEL: u32 = 91;
    pub const AK_MIDI_CC_TREMOLO_LEVEL: u32 = 92;
    pub const AK_MIDI_CC_CHORUS_LEVEL: u32 = 93;
    pub const AK_MIDI_CC_CELESTE_LEVEL: u32 = 94;
    pub const AK_MIDI_CC_PHASER_LEVEL: u32 = 95;
    pub const AK_MIDI_CC_DATA_BUTTON_P1: u32 = 96;
    pub const AK_MIDI_CC_DATA_BUTTON_M1: u32 = 97;
    pub const AK_MIDI_CC_NON_REGISTER_COARSE: u32 = 98;
    pub const AK_MIDI_CC_NON_REGISTER_FINE: u32 = 99;
    pub const AK_MIDI_CC_ALL_SOUND_OFF: u32 = 120;
    pub const AK_MIDI_CC_ALL_CONTROLLERS_OFF: u32 = 121;
    pub const AK_MIDI_CC_LOCAL_KEYBOARD: u32 = 122;
    pub const AK_MIDI_CC_ALL_NOTES_OFF: u32 = 123;
    pub const AK_MIDI_CC_OMNI_MODE_OFF: u32 = 124;
    pub const AK_MIDI_CC_OMNI_MODE_ON: u32 = 125;
    pub const AK_MIDI_CC_OMNI_MONOPHONIC_ON: u32 = 126;
    pub const AK_MIDI_CC_OMNI_POLYPHONIC_ON: u32 = 127;
    pub const AK_WWISESDK_VERSION_MAJOR: u32 = 2021;
    pub const AK_WWISESDK_VERSION_MINOR: u32 = 1;
    pub const AK_WWISESDK_VERSION_SUBMINOR: u32 = 11;
    pub const AK_WWISESDK_VERSION_BUILD: u32 = 7933;
    pub const AK_WWISESDK_BUILD_YEAR: u32 = 2022;
    pub const AK_WWISESDK_BUILD_MONTH: u32 = 11;
    pub const AK_WWISESDK_BUILD_DAY: u32 = 26;
    pub const AK_WWISESDK_BRANCH: &[u8; 14usize] = b"wwise_v2021.1\0";
    pub const AK_WWISESDK_COPYRIGHT: &[u8; 54usize] =
        b"(C) 2006-2022. Audiokinetic Inc. All rights reserved.\0";
    pub const AK_WWISESDK_COPYRIGHT_CONSOLE: &[u8; 54usize] =
        b"(C) 2006-2022. Audiokinetic Inc. All rights reserved.\0";
    pub const AK_WWISESDK_VERSION_COMBINED: u32 = 517377;
    pub const AK_MONITOR_STREAMNAME_MAXLENGTH: u32 = 64;
    pub const AK_MONITOR_DEVICENAME_MAXLENGTH: u32 = 16;
    pub const AK_SCHEDULER_BLOCKING: u32 = 1;
    pub const AK_SCHEDULER_DEFERRED_LINED_UP: u32 = 2;
    pub const AK_MIDI_WWISE_CMD_PLAY: u32 = 0;
    pub const AK_MIDI_WWISE_CMD_STOP: u32 = 1;
    pub const AK_MIDI_WWISE_CMD_PAUSE: u32 = 2;
    pub const AK_MIDI_WWISE_CMD_RESUME: u32 = 3;
    pub const AK_MIDI_WWISE_CMD_SEEK_MS: u32 = 4;
    pub const AK_MIDI_WWISE_CMD_SEEK_SAMPLES: u32 = 5;
    pub const AK_COMM_SETTINGS_MAX_STRING_SIZE: u32 = 64;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    pub type __int64_t = ::std::os::raw::c_longlong;
    pub type __darwin_intptr_t = ::std::os::raw::c_long;
    pub type __darwin_natural_t = ::std::os::raw::c_uint;
    pub type __darwin_size_t = ::std::os::raw::c_ulong;
    pub type __darwin_mach_port_name_t = root::__darwin_natural_t;
    pub type __darwin_mach_port_t = root::__darwin_mach_port_name_t;
    pub type __darwin_off_t = root::__int64_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __darwin_pthread_handler_rec {
        pub __routine:
            ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        pub __arg: *mut ::std::os::raw::c_void,
        pub __next: *mut root::__darwin_pthread_handler_rec,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _opaque_pthread_t {
        pub __sig: ::std::os::raw::c_long,
        pub __cleanup_stack: *mut root::__darwin_pthread_handler_rec,
        pub __opaque: [::std::os::raw::c_char; 8176usize],
    }
    pub type __darwin_pthread_t = *mut root::_opaque_pthread_t;
    pub type mach_port_t = root::__darwin_mach_port_t;
    pub type semaphore_t = root::mach_port_t;
    pub type AkEvent = root::semaphore_t;
    pub type AkSemaphore = root::semaphore_t;
    pub type AkStackTrace = [*mut ::std::os::raw::c_void; 64usize];
    pub type size_t = root::__darwin_size_t;
    pub type pthread_t = root::__darwin_pthread_t;
    pub type fpos_t = root::__darwin_off_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sbuf {
        pub _base: *mut ::std::os::raw::c_uchar,
        pub _size: ::std::os::raw::c_int,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sFILEX {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __sFILE {
        pub _p: *mut ::std::os::raw::c_uchar,
        pub _r: ::std::os::raw::c_int,
        pub _w: ::std::os::raw::c_int,
        pub _flags: ::std::os::raw::c_short,
        pub _file: ::std::os::raw::c_short,
        pub _bf: root::__sbuf,
        pub _lbfsize: ::std::os::raw::c_int,
        pub _cookie: *mut ::std::os::raw::c_void,
        pub _close: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
        >,
        pub _read: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *mut ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        pub _seek: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: root::fpos_t,
                arg3: ::std::os::raw::c_int,
            ) -> root::fpos_t,
        >,
        pub _write: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_char,
                arg3: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int,
        >,
        pub _ub: root::__sbuf,
        pub _extra: *mut root::__sFILEX,
        pub _ur: ::std::os::raw::c_int,
        pub _ubuf: [::std::os::raw::c_uchar; 3usize],
        pub _nbuf: [::std::os::raw::c_uchar; 1usize],
        pub _lb: root::__sbuf,
        pub _blksize: ::std::os::raw::c_int,
        pub _offset: root::fpos_t,
    }
    pub type FILE = root::__sFILE;
    pub type AkUInt8 = u8;
    pub type AkUInt16 = u16;
    pub type AkUInt32 = u32;
    pub type AkUInt64 = u64;
    pub type AkUIntPtr = usize;
    pub type AkInt8 = i8;
    pub type AkInt16 = i16;
    pub type AkInt32 = i32;
    pub type AkInt64 = i64;
    pub type AkIntPtr = isize;
    pub type AkOSChar = ::std::os::raw::c_char;
    pub type AkReal32 = f32;
    pub type AkReal64 = f64;
    pub type AkThread = root::pthread_t;
    pub type AkThreadID = root::pthread_t;
    pub type AkThreadRoutine = ::std::option::Option<
        unsafe extern "C" fn(
            lpThreadParameter: *mut ::std::os::raw::c_void,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type AkFileHandle = *mut root::FILE;
    pub type AkUtf16 = root::AkUInt16;
    pub type AkFourcc = root::AkUInt32;
    pub type AkUniqueID = root::AkUInt32;
    pub type AkStateID = root::AkUInt32;
    pub type AkStateGroupID = root::AkUInt32;
    pub type AkPlayingID = root::AkUInt32;
    pub type AkTimeMs = root::AkInt32;
    pub type AkPortNumber = root::AkUInt16;
    pub type AkPitchValue = root::AkReal32;
    pub type AkVolumeValue = root::AkReal32;
    pub type AkGameObjectID = root::AkUInt64;
    pub type AkLPFType = root::AkReal32;
    pub type AkMemPoolId = root::AkInt32;
    pub type AkPluginID = root::AkUInt32;
    pub type AkCodecID = root::AkUInt32;
    pub type AkAuxBusID = root::AkUInt32;
    pub type AkPluginParamID = root::AkInt16;
    pub type AkPriority = root::AkInt8;
    pub type AkDataCompID = root::AkUInt16;
    pub type AkDataTypeID = root::AkUInt16;
    pub type AkDataInterleaveID = root::AkUInt8;
    pub type AkSwitchGroupID = root::AkUInt32;
    pub type AkSwitchStateID = root::AkUInt32;
    pub type AkRtpcID = root::AkUInt32;
    pub type AkRtpcValue = root::AkReal32;
    pub type AkBankID = root::AkUInt32;
    pub type AkFileID = root::AkUInt32;
    pub type AkDeviceID = root::AkUInt32;
    pub type AkTriggerID = root::AkUInt32;
    pub type AkArgumentValueID = root::AkUInt32;
    pub type AkChannelMask = root::AkUInt32;
    pub type AkModulatorID = root::AkUInt32;
    pub type AkAcousticTextureID = root::AkUInt32;
    pub type AkImageSourceID = root::AkUInt32;
    pub type AkOutputDeviceID = root::AkUInt64;
    pub type AkPipelineID = root::AkUInt32;
    pub type AkRayID = root::AkUInt32;
    pub type AkAudioObjectID = root::AkUInt64;
    #[doc = "Invalid FX ID"]
    pub const AK_INVALID_PLUGINID: root::AkPluginID = 4294967295;
    #[doc = "Invalid unique 32-bit ID"]
    pub const AK_INVALID_UNIQUE_ID: root::AkUniqueID = 0;
    #[doc = "Invalid RTPC ID"]
    pub const AK_INVALID_RTPC_ID: root::AkRtpcID = 0;
    #[doc = "Invalid playing ID"]
    pub const AK_INVALID_PLAYING_ID: root::AkPlayingID = 0;
    #[doc = "Switch selected if no switch has been set yet"]
    pub const AK_DEFAULT_SWITCH_STATE: root::AkUInt32 = 0;
    #[doc = "Invalid pool ID"]
    pub const AK_INVALID_POOL_ID: root::AkMemPoolId = -1;
    #[doc = "Default pool ID, same as AK_INVALID_POOL_ID"]
    pub const AK_DEFAULT_POOL_ID: root::AkMemPoolId = -1;
    #[doc = "Invalid auxiliary bus ID (or no Aux bus ID)"]
    pub const AK_INVALID_AUX_ID: root::AkAuxBusID = 0;
    #[doc = "Invalid file ID"]
    pub const AK_INVALID_FILE_ID: root::AkFileID = 4294967295;
    #[doc = "Invalid streaming device ID"]
    pub const AK_INVALID_DEVICE_ID: root::AkDeviceID = 4294967295;
    #[doc = "Invalid bank ID"]
    pub const AK_INVALID_BANK_ID: root::AkBankID = 0;
    #[doc = "Fallback argument value ID"]
    pub const AK_FALLBACK_ARGUMENTVALUE_ID: root::AkArgumentValueID = 0;
    #[doc = "Invalid channel mask"]
    pub const AK_INVALID_CHANNELMASK: root::AkChannelMask = 0;
    #[doc = "Invalid Device ID"]
    pub const AK_INVALID_OUTPUT_DEVICE_ID: root::AkUInt32 = 0;
    #[doc = "Invalid pipeline ID (for profiling)"]
    pub const AK_INVALID_PIPELINE_ID: root::AkPipelineID = 0;
    #[doc = "Default sound / I/O priority"]
    pub const AK_DEFAULT_PRIORITY: root::AkPriority = 50;
    #[doc = "Minimal priority value [0,100]"]
    pub const AK_MIN_PRIORITY: root::AkPriority = 0;
    #[doc = "Maximal priority value [0,100]"]
    pub const AK_MAX_PRIORITY: root::AkPriority = 100;
    #[doc = " Default bank load I/O priority"]
    pub const AK_DEFAULT_BANK_IO_PRIORITY: root::AkPriority = 50;
    #[doc = " Default bank load throughput (1 Mb/ms)"]
    pub const AK_DEFAULT_BANK_THROUGHPUT: root::AkReal32 = 1048.5760498046875;
    #[doc = " Version of the soundbank reader"]
    pub const AK_SOUNDBANK_VERSION: root::AkUInt32 = 140;
    #[repr(u32)]
    #[doc = " Standard function call result."]
    #[must_use]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum AKRESULT {
        #[doc = "This feature is not implemented."]
        AK_NotImplemented = 0,
        #[doc = "The operation was successful."]
        AK_Success = 1,
        #[doc = "The operation failed."]
        AK_Fail = 2,
        #[doc = "The operation succeeded partially."]
        AK_PartialSuccess = 3,
        #[doc = "Incompatible formats"]
        AK_NotCompatible = 4,
        #[doc = "The stream is already connected to another node."]
        AK_AlreadyConnected = 5,
        #[doc = "An unexpected value causes the file to be invalid."]
        AK_InvalidFile = 7,
        #[doc = "The file header is too large."]
        AK_AudioFileHeaderTooLarge = 8,
        #[doc = "The maximum was reached."]
        AK_MaxReached = 9,
        #[doc = "The ID is invalid."]
        AK_InvalidID = 14,
        #[doc = "The ID was not found."]
        AK_IDNotFound = 15,
        #[doc = "The InstanceID is invalid."]
        AK_InvalidInstanceID = 16,
        #[doc = "No more data is available from the source."]
        AK_NoMoreData = 17,
        #[doc = "The StateGroup is not a valid channel."]
        AK_InvalidStateGroup = 20,
        #[doc = "The child already has a parent."]
        AK_ChildAlreadyHasAParent = 21,
        #[doc = "The language is invalid (applies to the Low-Level I/O)."]
        AK_InvalidLanguage = 22,
        #[doc = "It is not possible to add itself as its own child."]
        AK_CannotAddItseflAsAChild = 23,
        #[doc = "Something is not within bounds."]
        AK_InvalidParameter = 31,
        #[doc = "The item could not be added because it was already in the list."]
        AK_ElementAlreadyInList = 35,
        #[doc = "This path is not known."]
        AK_PathNotFound = 36,
        #[doc = "Stuff in vertices before trying to start it"]
        AK_PathNoVertices = 37,
        #[doc = "Only a running path can be paused."]
        AK_PathNotRunning = 38,
        #[doc = "Only a paused path can be resumed."]
        AK_PathNotPaused = 39,
        #[doc = "This path is already there."]
        AK_PathNodeAlreadyInList = 40,
        #[doc = "This path is not there."]
        AK_PathNodeNotInList = 41,
        #[doc = "The consumer needs more."]
        AK_DataNeeded = 43,
        #[doc = "The consumer does not need more."]
        AK_NoDataNeeded = 44,
        #[doc = "The provider has available data."]
        AK_DataReady = 45,
        #[doc = "The provider does not have available data."]
        AK_NoDataReady = 46,
        #[doc = "Memory error."]
        AK_InsufficientMemory = 52,
        #[doc = "The requested action was cancelled (not an error)."]
        AK_Cancelled = 53,
        #[doc = "Trying to load a bank using an ID which is not defined."]
        AK_UnknownBankID = 54,
        #[doc = "Error while reading a bank."]
        AK_BankReadError = 56,
        #[doc = "Invalid switch type (used with the switch container)"]
        AK_InvalidSwitchType = 57,
        #[doc = "Source format not known yet."]
        AK_FormatNotReady = 63,
        #[doc = "The bank version is not compatible with the current bank reader."]
        AK_WrongBankVersion = 64,
        #[doc = "File not found."]
        AK_FileNotFound = 66,
        #[doc = "Specified ID doesn't match a valid hardware device: either the device doesn't exist or is disabled."]
        AK_DeviceNotReady = 67,
        #[doc = "The bank load failed because the bank is already loaded."]
        AK_BankAlreadyLoaded = 69,
        #[doc = "The effect on the node is rendered."]
        AK_RenderedFX = 71,
        #[doc = "A routine needs to be executed on some CPU."]
        AK_ProcessNeeded = 72,
        #[doc = "The executed routine has finished its execution."]
        AK_ProcessDone = 73,
        #[doc = "The memory manager should have been initialized at this point."]
        AK_MemManagerNotInitialized = 74,
        #[doc = "The stream manager should have been initialized at this point."]
        AK_StreamMgrNotInitialized = 75,
        #[doc = "The machine does not support SSE instructions (required on PC)."]
        AK_SSEInstructionsNotSupported = 76,
        #[doc = "The system is busy and could not process the request."]
        AK_Busy = 77,
        #[doc = "Channel configuration is not supported in the current execution context."]
        AK_UnsupportedChannelConfig = 78,
        #[doc = "Plugin media is not available for effect."]
        AK_PluginMediaNotAvailable = 79,
        #[doc = "Sound was Not Allowed to play."]
        AK_MustBeVirtualized = 80,
        #[doc = "SDK command is too large to fit in the command queue."]
        AK_CommandTooLarge = 81,
        #[doc = "A play request was rejected due to the MIDI filter parameters."]
        AK_RejectedByFilter = 82,
        #[doc = "Detecting incompatibility between Custom platform of banks and custom platform of connected application"]
        AK_InvalidCustomPlatformName = 83,
        #[doc = "Plugin DLL could not be loaded, either because it is not found or one dependency is missing."]
        AK_DLLCannotLoad = 84,
        #[doc = "Plugin DLL search path could not be found."]
        AK_DLLPathNotFound = 85,
        #[doc = "No Java VM provided in AkInitSettings."]
        AK_NoJavaVM = 86,
        #[doc = "OpenSL returned an error.  Check error log for more details."]
        AK_OpenSLError = 87,
        #[doc = "Plugin is not registered.  Make sure to implement a AK::PluginRegistration class for it and use AK_STATIC_LINK_PLUGIN in the game binary."]
        AK_PluginNotRegistered = 88,
        #[doc = "A pointer to audio data was not aligned to the platform's required alignment (check AkTypes.h in the platform-specific folder)"]
        AK_DataAlignmentError = 89,
        #[doc = "Incompatible Audio device."]
        AK_DeviceNotCompatible = 90,
        #[doc = "Two Wwise objects share the same ID."]
        AK_DuplicateUniqueID = 91,
        #[doc = "The Init bank was not loaded yet, the sound engine isn't completely ready yet."]
        AK_InitBankNotLoaded = 92,
        #[doc = "The specified device ID does not match with any of the output devices that the sound engine is currently using."]
        AK_DeviceNotFound = 93,
        #[doc = "Calling a function with a playing ID that is not known."]
        AK_PlayingIDNotFound = 94,
        #[doc = "One parameter has a invalid float value such as NaN, INF or FLT_MAX."]
        AK_InvalidFloatValue = 95,
        #[doc = "Media file format unexpected"]
        AK_FileFormatMismatch = 96,
        #[doc = "No distinct listener provided for AddOutput"]
        AK_NoDistinctListener = 97,
        #[doc = "Generic XMA decoder error."]
        AK_ACP_Error = 98,
        #[doc = "Resource is in use and cannot be released."]
        AK_ResourceInUse = 99,
    }
    #[repr(u32)]
    #[doc = " Game sync group type"]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum AkGroupType {
        #[doc = "Type switch"]
        AkGroupType_Switch = 0,
        #[doc = "Type state"]
        AkGroupType_State = 1,
    }
    #[doc = " Configured audio settings"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkAudioSettings {
        #[doc = "Number of samples per audio frame (256, 512, 1024 or 2048)."]
        pub uNumSamplesPerFrame: root::AkUInt32,
        #[doc = "Number of samples per second."]
        pub uNumSamplesPerSecond: root::AkUInt32,
    }
    impl AkAudioDeviceState {
        #[doc = "The audio device state is unknown or invalid."]
        pub const AkDeviceState_Unknown: root::AkAudioDeviceState = root::AkAudioDeviceState(0);
    }
    impl AkAudioDeviceState {
        #[doc = "The audio device is active That is, the audio adapter that connects to the endpoint device is present and enabled."]
        pub const AkDeviceState_Active: root::AkAudioDeviceState = root::AkAudioDeviceState(1);
    }
    impl AkAudioDeviceState {
        #[doc = "The audio device is disabled."]
        pub const AkDeviceState_Disabled: root::AkAudioDeviceState = root::AkAudioDeviceState(2);
    }
    impl AkAudioDeviceState {
        #[doc = "The audio device is not present because the audio adapter that connects to the endpoint device has been removed from the system."]
        pub const AkDeviceState_NotPresent: root::AkAudioDeviceState = root::AkAudioDeviceState(4);
    }
    impl AkAudioDeviceState {
        #[doc = "The audio device is unplugged."]
        pub const AkDeviceState_Unplugged: root::AkAudioDeviceState = root::AkAudioDeviceState(8);
    }
    impl AkAudioDeviceState {
        #[doc = "Includes audio devices in all states."]
        pub const AkDeviceState_All: root::AkAudioDeviceState = root::AkAudioDeviceState(15);
    }
    impl ::std::ops::BitOr<root::AkAudioDeviceState> for root::AkAudioDeviceState {
        type Output = Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            AkAudioDeviceState(self.0 | other.0)
        }
    }
    impl ::std::ops::BitOrAssign for root::AkAudioDeviceState {
        #[inline]
        fn bitor_assign(&mut self, rhs: root::AkAudioDeviceState) {
            self.0 |= rhs.0;
        }
    }
    impl ::std::ops::BitAnd<root::AkAudioDeviceState> for root::AkAudioDeviceState {
        type Output = Self;
        #[inline]
        fn bitand(self, other: Self) -> Self {
            AkAudioDeviceState(self.0 & other.0)
        }
    }
    impl ::std::ops::BitAndAssign for root::AkAudioDeviceState {
        #[inline]
        fn bitand_assign(&mut self, rhs: root::AkAudioDeviceState) {
            self.0 &= rhs.0;
        }
    }
    #[repr(transparent)]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct AkAudioDeviceState(pub ::std::os::raw::c_uint);
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkDeviceDescription {
        #[doc = "Device ID for Wwise. This is the same as what is returned from AK::GetDeviceID and AK::GetDeviceIDFromName. Use it to specify the main device in AkPlatformInitSettings.idAudioDevice or in AK::SoundEngine::AddSecondaryOutput."]
        pub idDevice: root::AkUInt32,
        #[doc = "The user-friendly name for the device."]
        pub deviceName: [root::AkOSChar; 260usize],
        #[doc = "Bitmask used to filter the device based on their state."]
        pub deviceStateMask: root::AkAudioDeviceState,
        #[doc = "Identify default device. Always false when not supported."]
        pub isDefaultDevice: bool,
    }
    #[doc = " This structure allows the game to provide audio files to fill the external sources. See \\ref AK::SoundEngine::PostEvent"]
    #[doc = " You can specify a streaming file or a file in-memory, regardless of the \"Stream\" option in the Wwise project."]
    #[doc = " \\akwarning"]
    #[doc = " Make sure that only one of szFile, pInMemory or idFile is non-null. if both idFile and szFile are set, idFile is passed to low-level IO and szFile is used as stream name (for profiling purposes)."]
    #[doc = " \\endakwarning"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkExternalSourceInfo {
        #[doc = "Cookie identifying the source, given by hashing the name of the source given in the project.  See \\ref AK::SoundEngine::GetIDFromString. \\aknote If an event triggers the playback of more than one external source, they must be named uniquely in the project therefore have a unique cookie) in order to tell them apart when filling the AkExternalSourceInfo structures. \\endaknote"]
        pub iExternalSrcCookie: root::AkUInt32,
        #[doc = "Codec ID for the file.  One of the audio formats defined in AkTypes.h (AKCODECID_XXX)"]
        pub idCodec: root::AkCodecID,
        #[doc = "File path for the source.  If not NULL, the source will be streaming from disk.  Set pInMemory to NULL. If idFile is set, this field is used as stream name (for profiling purposes)."]
        pub szFile: *mut root::AkOSChar,
        #[doc = "Pointer to the in-memory file.  If not NULL, the source will be read from memory.  Set szFile and idFile to NULL."]
        pub pInMemory: *mut ::std::os::raw::c_void,
        #[doc = "Size of the data pointed by pInMemory"]
        pub uiMemorySize: root::AkUInt32,
        #[doc = "File ID.  If not zero, the source will be streaming from disk.  This ID can be anything.  Note that you must override the low-level IO to resolve this ID to a real file.  See \\ref streamingmanager_lowlevel for more information on overriding the Low Level IO."]
        pub idFile: root::AkFileID,
    }
    #[repr(u32)]
    #[doc = " Nature of the connection binding an input to a bus."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum AkConnectionType {
        #[doc = "Direct (main, dry) connection."]
        ConnectionType_Direct = 0,
        #[doc = "Connection by a game-defined send."]
        ConnectionType_GameDefSend = 1,
        #[doc = "Connection by a user-defined send."]
        ConnectionType_UserDefSend = 2,
        #[doc = "Connection by a early reflections send."]
        ConnectionType_ReflectionsSend = 3,
    }
    #[doc = " 3D vector."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkVector {
        #[doc = "X Position"]
        pub X: root::AkReal32,
        #[doc = "Y Position"]
        pub Y: root::AkReal32,
        #[doc = "Z Position"]
        pub Z: root::AkReal32,
    }
    #[doc = " Position and orientation of game objects."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkTransform {
        #[doc = "Orientation of the listener"]
        pub orientationFront: root::AkVector,
        #[doc = "Top orientation of the listener"]
        pub orientationTop: root::AkVector,
        #[doc = "Position of the listener"]
        pub position: root::AkVector,
    }
    #[doc = " Position and orientation of game objects."]
    pub type AkSoundPosition = root::AkTransform;
    #[doc = " Position and orientation of game objects."]
    pub type AkListenerPosition = root::AkTransform;
    #[doc = " Obstruction/occlusion pair for a position"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkObstructionOcclusionValues {
        #[doc = "OcclusionLevel: [0.0f..1.0f]"]
        pub occlusion: root::AkReal32,
        #[doc = "ObstructionLevel: [0.0f..1.0f]"]
        pub obstruction: root::AkReal32,
    }
    #[doc = " Positioning information for a sound, with specified subset of its channels."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkChannelEmitter {
        #[doc = "Emitter position."]
        pub position: root::AkTransform,
        #[doc = "Channels to which the above position applies."]
        pub uInputChannels: root::AkChannelMask,
    }
    #[doc = " Polar coordinates."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkPolarCoord {
        #[doc = "Norm/distance"]
        pub r: root::AkReal32,
        #[doc = "Azimuth"]
        pub theta: root::AkReal32,
    }
    #[doc = " Spherical coordinates."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkSphericalCoord {
        pub _base: root::AkPolarCoord,
        #[doc = "Elevation"]
        pub phi: root::AkReal32,
    }
    #[doc = " Emitter-listener pair: Positioning data pertaining to a single pair of emitter and listener."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct AkEmitterListenerPair {
        #[doc = "Emitter position."]
        pub emitter: root::AkTransform,
        #[doc = "Distance between emitter and listener."]
        pub fDistance: root::AkReal32,
        #[doc = "Angle between position vector and emitter orientation."]
        pub fEmitterAngle: root::AkReal32,
        #[doc = "Angle between position vector and listener orientation."]
        pub fListenerAngle: root::AkReal32,
        #[doc = "Emitter-listener-pair-specific gain (due to distance and cone attenuation) for direct connections."]
        pub fDryMixGain: root::AkReal32,
        #[doc = "Emitter-listener-pair-specific gain (due to distance and cone attenuation) for game-defined send connections."]
        pub fGameDefAuxMixGain: root::AkReal32,
        #[doc = "Emitter-listener-pair-specific gain (due to distance and cone attenuation) for user-defined send connections."]
        pub fUserDefAuxMixGain: root::AkReal32,
        #[doc = "Emitter-listener-pair-specific occlusion factor"]
        pub fOcclusion: root::AkReal32,
        #[doc = "Emitter-listener-pair-specific obstruction factor"]
        pub fObstruction: root::AkReal32,
        #[doc = "Emitter-listener-pair-specific diffraction coefficient"]
        pub fDiffraction: root::AkReal32,
        #[doc = "Emitter-listener-pair-specific transmission occlusion."]
        pub fTransmissionLoss: root::AkReal32,
        #[doc = "Emitter-listener-pair-specific spread"]
        pub fSpread: root::AkReal32,
        #[doc = "Emitter-listener-pair-specific aperture"]
        pub fAperture: root::AkReal32,
        #[doc = "Combined scaling factor due to both emitter and listener."]
        pub fScalingFactor: root::AkReal32,
        #[doc = "Channels of the emitter that apply to this ray."]
        pub uEmitterChannelMask: root::AkChannelMask,
        #[doc = "ID of this emitter-listener pair, unique for a given emitter."]
        pub id: root::AkRayID,
        #[doc = "Listener game object ID."]
        pub m_uListenerID: root::AkGameObjectID,
    }
    #[doc = " Listener information."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkListener {
        pub position: root::AkListenerPosition,
        #[doc = " Listener position (see AK::SoundEngine::SetPosition())."]
        pub fScalingFactor: root::AkReal32,
        #[doc = " Listener scaling factor (see AK::SoundEngine::SetListenerScalingFactor())."]
        pub bSpatialized: bool,
    }
    impl root::AkCurveInterpolation {
        pub const AkCurveInterpolation_LastFadeCurve: root::AkCurveInterpolation =
            AkCurveInterpolation::AkCurveInterpolation_Exp3;
    }
    #[repr(u32)]
    #[doc = " Curve interpolation types"]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum AkCurveInterpolation {
        #[doc = "Log3"]
        AkCurveInterpolation_Log3 = 0,
        #[doc = "Sine"]
        AkCurveInterpolation_Sine = 1,
        #[doc = "Log1"]
        AkCurveInterpolation_Log1 = 2,
        #[doc = "Inversed S Curve"]
        AkCurveInterpolation_InvSCurve = 3,
        #[doc = "Linear (Default)"]
        AkCurveInterpolation_Linear = 4,
        #[doc = "S Curve"]
        AkCurveInterpolation_SCurve = 5,
        #[doc = "Exp1"]
        AkCurveInterpolation_Exp1 = 6,
        #[doc = "Reciprocal of sine curve"]
        AkCurveInterpolation_SineRecip = 7,
        #[doc = "Exp3"]
        AkCurveInterpolation_Exp3 = 8,
        #[doc = "Constant ( not valid for fading values )"]
        AkCurveInterpolation_Constant = 9,
    }
    #[doc = " Auxiliary bus sends information per game object per given auxiliary bus."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkAuxSendValue {
        #[doc = "Game object ID of the listener associated with this send. Use AK_INVALID_GAME_OBJECT as a wildcard to set the auxiliary send to all connected listeners (see AK::SoundEngine::SetListeners)."]
        pub listenerID: root::AkGameObjectID,
        #[doc = "Auxiliary bus ID."]
        pub auxBusID: root::AkAuxBusID,
        #[doc = "A value in the range [0.0f:16.0f] ( -∞ dB to +24 dB)."]
        #[doc = "Represents the attenuation or amplification factor applied to the volume of the sound going through the auxiliary bus."]
        #[doc = "A value greater than 1.0f will amplify the sound."]
        pub fControlValue: root::AkReal32,
    }
    #[doc = " Volume ramp specified by end points \"previous\" and \"next\"."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkRamp {
        pub fPrev: root::AkReal32,
        pub fNext: root::AkReal32,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct IAkSoftwareCodec {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct IAkFileCodec {
        _unused: [u8; 0],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct IAkGrainCodec {
        _unused: [u8; 0],
    }
    pub type AkCreateFileSourceCallback = ::std::option::Option<
        unsafe extern "C" fn(in_pCtx: *mut ::std::os::raw::c_void) -> *mut root::IAkSoftwareCodec,
    >;
    pub type AkCreateBankSourceCallback = ::std::option::Option<
        unsafe extern "C" fn(in_pCtx: *mut ::std::os::raw::c_void) -> *mut root::IAkSoftwareCodec,
    >;
    pub type AkCreateFileCodecCallback =
        ::std::option::Option<unsafe extern "C" fn() -> *mut root::IAkFileCodec>;
    pub type AkCreateGrainCodecCallback =
        ::std::option::Option<unsafe extern "C" fn() -> *mut root::IAkGrainCodec>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkCodecDescriptor {
        pub pFileSrcCreateFunc: root::AkCreateFileSourceCallback,
        pub pBankSrcCreateFunc: root::AkCreateBankSourceCallback,
        pub pFileCodecCreateFunc: root::AkCreateFileCodecCallback,
        pub pGrainCodecCreateFunc: root::AkCreateGrainCodecCallback,
    }
    pub mod AK {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod SoundEngine {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[doc = "Used for normal sounds, not expected to pass to AK::SoundEngine::SetMultiplePosition() (if done, only the first position will be used)."]
            pub const MultiPositionType_MultiPositionType_SingleSource:
                root::AK::SoundEngine::MultiPositionType = 0;
            #[doc = "Simulate multiple sources in one sound playing, adding volumes. For instance, all the torches on your level emitting using only one sound."]
            pub const MultiPositionType_MultiPositionType_MultiSources:
                root::AK::SoundEngine::MultiPositionType = 1;
            #[doc = "Simulate one sound coming from multiple directions. Useful for repositionning sounds based on wall openings or to simulate areas like forest or rivers ( in combination with spreading in the attenuation of the sounds )."]
            pub const MultiPositionType_MultiPositionType_MultiDirections:
                root::AK::SoundEngine::MultiPositionType = 2;
            #[doc = " MultiPositionType."]
            #[doc = " \\sa"]
            #[doc = " - AK::SoundEngine::SetMultiplePosition()"]
            #[doc = " - \\ref soundengine_3dpositions_multiplepos"]
            pub type MultiPositionType = ::std::os::raw::c_uint;
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine13IsInitializedEv"]
                pub fn IsInitialized() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine4InitEP14AkInitSettingsP22AkPlatformInitSettings"]
                pub fn Init(
                    in_pSettings: *mut root::AkInitSettings,
                    in_pPlatformSettings: *mut root::AkPlatformInitSettings,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine22GetDefaultInitSettingsER14AkInitSettings"]
                pub fn GetDefaultInitSettings(out_settings: *mut root::AkInitSettings);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine30GetDefaultPlatformInitSettingsER22AkPlatformInitSettings"]
                pub fn GetDefaultPlatformInitSettings(
                    out_platformSettings: *mut root::AkPlatformInitSettings,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine4TermEv"]
                pub fn Term();
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine16GetAudioSettingsER15AkAudioSettings"]
                pub fn GetAudioSettings(
                    out_audioSettings: *mut root::AkAudioSettings,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine23GetSpeakerConfigurationEy"]
                pub fn GetSpeakerConfiguration(
                    in_idOutput: root::AkOutputDeviceID,
                ) -> root::AkChannelConfig;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine28GetOutputDeviceConfigurationEyR15AkChannelConfigR25Ak3DAudioSinkCapabilities"]
                pub fn GetOutputDeviceConfiguration(
                    in_idOutput: root::AkOutputDeviceID,
                    io_channelConfig: *mut root::AkChannelConfig,
                    io_capabilities: *mut root::Ak3DAudioSinkCapabilities,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine14GetPanningRuleER13AkPanningRuley"]
                pub fn GetPanningRule(
                    out_ePanningRule: *mut root::AkPanningRule,
                    in_idOutput: root::AkOutputDeviceID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine14SetPanningRuleE13AkPanningRuley"]
                pub fn SetPanningRule(
                    in_ePanningRule: root::AkPanningRule,
                    in_idOutput: root::AkOutputDeviceID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine16GetSpeakerAnglesEPfRjRfy"]
                pub fn GetSpeakerAngles(
                    io_pfSpeakerAngles: *mut root::AkReal32,
                    io_uNumAngles: *mut root::AkUInt32,
                    out_fHeightAngle: *mut root::AkReal32,
                    in_idOutput: root::AkOutputDeviceID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine16SetSpeakerAnglesEPKfjfy"]
                pub fn SetSpeakerAngles(
                    in_pfSpeakerAngles: *const root::AkReal32,
                    in_uNumAngles: root::AkUInt32,
                    in_fHeightAngle: root::AkReal32,
                    in_idOutput: root::AkOutputDeviceID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine18SetVolumeThresholdEf"]
                pub fn SetVolumeThreshold(in_fVolumeThresholdDB: root::AkReal32) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine20SetMaxNumVoicesLimitEt"]
                pub fn SetMaxNumVoicesLimit(in_maxNumberVoices: root::AkUInt16) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11RenderAudioEb"]
                pub fn RenderAudio(in_bAllowSyncRender: bool) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine22GetGlobalPluginContextEv"]
                pub fn GetGlobalPluginContext() -> *mut root::AK::IAkGlobalPluginContext;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine14RegisterPluginE12AkPluginTypejjPFPNS_9IAkPluginEPNS_17IAkPluginMemAllocEEPFPNS_14IAkPluginParamES5_EPF8AKRESULTRjP19AkDeviceDescriptionE"]
                pub fn RegisterPlugin(
                    in_eType: root::AkPluginType,
                    in_ulCompanyID: root::AkUInt32,
                    in_ulPluginID: root::AkUInt32,
                    in_pCreateFunc: root::AkCreatePluginCallback,
                    in_pCreateParamFunc: root::AkCreateParamCallback,
                    in_pGetDeviceList: root::AkGetDeviceListCallback,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine17RegisterPluginDLLEPKcS2_"]
                pub fn RegisterPluginDLL(
                    in_DllName: *const root::AkOSChar,
                    in_DllPath: *const root::AkOSChar,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine13RegisterCodecEjjPFP16IAkSoftwareCodecPvES5_"]
                pub fn RegisterCodec(
                    in_ulCompanyID: root::AkUInt32,
                    in_ulCodecID: root::AkUInt32,
                    in_pFileCreateFunc: root::AkCreateFileSourceCallback,
                    in_pBankCreateFunc: root::AkCreateBankSourceCallback,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine22RegisterGlobalCallbackEPFvPNS_22IAkGlobalPluginContextE24AkGlobalCallbackLocationPvEjS4_12AkPluginTypejj"]
                pub fn RegisterGlobalCallback(
                    in_pCallback: root::AkGlobalCallbackFunc,
                    in_eLocation: root::AkUInt32,
                    in_pCookie: *mut ::std::os::raw::c_void,
                    in_eType: root::AkPluginType,
                    in_ulCompanyID: root::AkUInt32,
                    in_ulPluginID: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine24UnregisterGlobalCallbackEPFvPNS_22IAkGlobalPluginContextE24AkGlobalCallbackLocationPvEj"]
                pub fn UnregisterGlobalCallback(
                    in_pCallback: root::AkGlobalCallbackFunc,
                    in_eLocation: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine31RegisterResourceMonitorCallbackEPFvPK28AkResourceMonitorDataSummaryE"]
                pub fn RegisterResourceMonitorCallback(
                    in_pCallback: root::AkResourceMonitorCallbackFunc,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine33UnregisterResourceMonitorCallbackEPFvPK28AkResourceMonitorDataSummaryE"]
                pub fn UnregisterResourceMonitorCallback(
                    in_pCallback: root::AkResourceMonitorCallbackFunc,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine33RegisterAudioDeviceStatusCallbackEPFvPNS_22IAkGlobalPluginContextEjjNS_18AkAudioDeviceEventE8AKRESULTE"]
                pub fn RegisterAudioDeviceStatusCallback(
                    in_pCallback: root::AK::AkDeviceStatusCallbackFunc,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine35UnregisterAudioDeviceStatusCallbackEv"]
                pub fn UnregisterAudioDeviceStatusCallback() -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine15GetIDFromStringEPKw"]
                pub fn GetIDFromString(in_pszString: *const u32) -> root::AkUInt32;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine15GetIDFromStringEPKc"]
                pub fn GetIDFromString1(
                    in_pszString: *const ::std::os::raw::c_char,
                ) -> root::AkUInt32;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine9PostEventEjyjPFv14AkCallbackTypeP14AkCallbackInfoEPvjP20AkExternalSourceInfoj"]
                pub fn PostEvent(
                    in_eventID: root::AkUniqueID,
                    in_gameObjectID: root::AkGameObjectID,
                    in_uFlags: root::AkUInt32,
                    in_pfnCallback: root::AkCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                    in_cExternals: root::AkUInt32,
                    in_pExternalSources: *mut root::AkExternalSourceInfo,
                    in_PlayingID: root::AkPlayingID,
                ) -> root::AkPlayingID;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine9PostEventEPKwyjPFv14AkCallbackTypeP14AkCallbackInfoEPvjP20AkExternalSourceInfoj"]
                pub fn PostEvent1(
                    in_pszEventName: *const u32,
                    in_gameObjectID: root::AkGameObjectID,
                    in_uFlags: root::AkUInt32,
                    in_pfnCallback: root::AkCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                    in_cExternals: root::AkUInt32,
                    in_pExternalSources: *mut root::AkExternalSourceInfo,
                    in_PlayingID: root::AkPlayingID,
                ) -> root::AkPlayingID;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine9PostEventEPKcyjPFv14AkCallbackTypeP14AkCallbackInfoEPvjP20AkExternalSourceInfoj"]
                pub fn PostEvent2(
                    in_pszEventName: *const ::std::os::raw::c_char,
                    in_gameObjectID: root::AkGameObjectID,
                    in_uFlags: root::AkUInt32,
                    in_pfnCallback: root::AkCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                    in_cExternals: root::AkUInt32,
                    in_pExternalSources: *mut root::AkExternalSourceInfo,
                    in_PlayingID: root::AkPlayingID,
                ) -> root::AkPlayingID;
            }
            #[doc = "Stop"]
            pub const AkActionOnEventType_AkActionOnEventType_Stop:
                root::AK::SoundEngine::AkActionOnEventType = 0;
            #[doc = "Pause"]
            pub const AkActionOnEventType_AkActionOnEventType_Pause:
                root::AK::SoundEngine::AkActionOnEventType = 1;
            #[doc = "Resume"]
            pub const AkActionOnEventType_AkActionOnEventType_Resume:
                root::AK::SoundEngine::AkActionOnEventType = 2;
            #[doc = "Break"]
            pub const AkActionOnEventType_AkActionOnEventType_Break:
                root::AK::SoundEngine::AkActionOnEventType = 3;
            #[doc = "Release envelope"]
            pub const AkActionOnEventType_AkActionOnEventType_ReleaseEnvelope:
                root::AK::SoundEngine::AkActionOnEventType = 4;
            #[doc = " AkActionOnEventType"]
            #[doc = " \\sa"]
            #[doc = " - <tt>AK::SoundEngine::ExecuteActionOnEvent()</tt>"]
            pub type AkActionOnEventType = ::std::os::raw::c_uint;
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine20ExecuteActionOnEventEjNS0_19AkActionOnEventTypeEyi20AkCurveInterpolationj"]
                pub fn ExecuteActionOnEvent(
                    in_eventID: root::AkUniqueID,
                    in_ActionType: root::AK::SoundEngine::AkActionOnEventType,
                    in_gameObjectID: root::AkGameObjectID,
                    in_uTransitionDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                    in_PlayingID: root::AkPlayingID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine20ExecuteActionOnEventEPKwNS0_19AkActionOnEventTypeEyi20AkCurveInterpolationj"]
                pub fn ExecuteActionOnEvent1(
                    in_pszEventName: *const u32,
                    in_ActionType: root::AK::SoundEngine::AkActionOnEventType,
                    in_gameObjectID: root::AkGameObjectID,
                    in_uTransitionDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                    in_PlayingID: root::AkPlayingID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine20ExecuteActionOnEventEPKcNS0_19AkActionOnEventTypeEyi20AkCurveInterpolationj"]
                pub fn ExecuteActionOnEvent2(
                    in_pszEventName: *const ::std::os::raw::c_char,
                    in_ActionType: root::AK::SoundEngine::AkActionOnEventType,
                    in_gameObjectID: root::AkGameObjectID,
                    in_uTransitionDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                    in_PlayingID: root::AkPlayingID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine15PostMIDIOnEventEjyP10AkMIDIPosttbjPFv14AkCallbackTypeP14AkCallbackInfoEPvj"]
                pub fn PostMIDIOnEvent(
                    in_eventID: root::AkUniqueID,
                    in_gameObjectID: root::AkGameObjectID,
                    in_pPosts: *mut root::AkMIDIPost,
                    in_uNumPosts: root::AkUInt16,
                    in_bAbsoluteOffsets: bool,
                    in_uFlags: root::AkUInt32,
                    in_pfnCallback: root::AkCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                    in_playingID: root::AkPlayingID,
                ) -> root::AkPlayingID;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine15StopMIDIOnEventEjyj"]
                pub fn StopMIDIOnEvent(
                    in_eventID: root::AkUniqueID,
                    in_gameObjectID: root::AkGameObjectID,
                    in_playingID: root::AkPlayingID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine21PinEventInStreamCacheEjaa"]
                pub fn PinEventInStreamCache(
                    in_eventID: root::AkUniqueID,
                    in_uActivePriority: root::AkPriority,
                    in_uInactivePriority: root::AkPriority,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine21PinEventInStreamCacheEPKwaa"]
                pub fn PinEventInStreamCache1(
                    in_pszEventName: *const u32,
                    in_uActivePriority: root::AkPriority,
                    in_uInactivePriority: root::AkPriority,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine21PinEventInStreamCacheEPKcaa"]
                pub fn PinEventInStreamCache2(
                    in_pszEventName: *const ::std::os::raw::c_char,
                    in_uActivePriority: root::AkPriority,
                    in_uInactivePriority: root::AkPriority,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine23UnpinEventInStreamCacheEj"]
                pub fn UnpinEventInStreamCache(in_eventID: root::AkUniqueID) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine23UnpinEventInStreamCacheEPKw"]
                pub fn UnpinEventInStreamCache1(in_pszEventName: *const u32) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine23UnpinEventInStreamCacheEPKc"]
                pub fn UnpinEventInStreamCache2(
                    in_pszEventName: *const ::std::os::raw::c_char,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine29GetBufferStatusForPinnedEventEjRfRb"]
                pub fn GetBufferStatusForPinnedEvent(
                    in_eventID: root::AkUniqueID,
                    out_fPercentBuffered: *mut root::AkReal32,
                    out_bCachePinnedMemoryFull: *mut bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine29GetBufferStatusForPinnedEventEPKcRfRb"]
                pub fn GetBufferStatusForPinnedEvent1(
                    in_pszEventName: *const ::std::os::raw::c_char,
                    out_fPercentBuffered: *mut root::AkReal32,
                    out_bCachePinnedMemoryFull: *mut bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine29GetBufferStatusForPinnedEventEPKwRfRb"]
                pub fn GetBufferStatusForPinnedEvent2(
                    in_pszEventName: *const u32,
                    out_fPercentBuffered: *mut root::AkReal32,
                    out_bCachePinnedMemoryFull: *mut bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11SeekOnEventEjyibj"]
                pub fn SeekOnEvent(
                    in_eventID: root::AkUniqueID,
                    in_gameObjectID: root::AkGameObjectID,
                    in_iPosition: root::AkTimeMs,
                    in_bSeekToNearestMarker: bool,
                    in_PlayingID: root::AkPlayingID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11SeekOnEventEPKwyibj"]
                pub fn SeekOnEvent1(
                    in_pszEventName: *const u32,
                    in_gameObjectID: root::AkGameObjectID,
                    in_iPosition: root::AkTimeMs,
                    in_bSeekToNearestMarker: bool,
                    in_PlayingID: root::AkPlayingID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11SeekOnEventEPKcyibj"]
                pub fn SeekOnEvent2(
                    in_pszEventName: *const ::std::os::raw::c_char,
                    in_gameObjectID: root::AkGameObjectID,
                    in_iPosition: root::AkTimeMs,
                    in_bSeekToNearestMarker: bool,
                    in_PlayingID: root::AkPlayingID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11SeekOnEventEjyfbj"]
                pub fn SeekOnEvent3(
                    in_eventID: root::AkUniqueID,
                    in_gameObjectID: root::AkGameObjectID,
                    in_fPercent: root::AkReal32,
                    in_bSeekToNearestMarker: bool,
                    in_PlayingID: root::AkPlayingID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11SeekOnEventEPKwyfbj"]
                pub fn SeekOnEvent4(
                    in_pszEventName: *const u32,
                    in_gameObjectID: root::AkGameObjectID,
                    in_fPercent: root::AkReal32,
                    in_bSeekToNearestMarker: bool,
                    in_PlayingID: root::AkPlayingID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11SeekOnEventEPKcyfbj"]
                pub fn SeekOnEvent5(
                    in_pszEventName: *const ::std::os::raw::c_char,
                    in_gameObjectID: root::AkGameObjectID,
                    in_fPercent: root::AkReal32,
                    in_bSeekToNearestMarker: bool,
                    in_PlayingID: root::AkPlayingID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine25CancelEventCallbackCookieEPv"]
                pub fn CancelEventCallbackCookie(in_pCookie: *mut ::std::os::raw::c_void);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine29CancelEventCallbackGameObjectEy"]
                pub fn CancelEventCallbackGameObject(in_gameObjectID: root::AkGameObjectID);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine19CancelEventCallbackEj"]
                pub fn CancelEventCallback(in_playingID: root::AkPlayingID);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine21GetSourcePlayPositionEjPib"]
                pub fn GetSourcePlayPosition(
                    in_PlayingID: root::AkPlayingID,
                    out_puPosition: *mut root::AkTimeMs,
                    in_bExtrapolate: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine22GetSourcePlayPositionsEjP16AkSourcePositionPjb"]
                pub fn GetSourcePlayPositions(
                    in_PlayingID: root::AkPlayingID,
                    out_puPositions: *mut root::AkSourcePosition,
                    io_pcPositions: *mut root::AkUInt32,
                    in_bExtrapolate: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine24GetSourceStreamBufferingEjRiRb"]
                pub fn GetSourceStreamBuffering(
                    in_PlayingID: root::AkPlayingID,
                    out_buffering: *mut root::AkTimeMs,
                    out_bIsBuffering: *mut bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine7StopAllEy"]
                pub fn StopAll(in_gameObjectID: root::AkGameObjectID);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine13StopPlayingIDEji20AkCurveInterpolation"]
                pub fn StopPlayingID(
                    in_playingID: root::AkPlayingID,
                    in_uTransitionDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine24ExecuteActionOnPlayingIDENS0_19AkActionOnEventTypeEji20AkCurveInterpolation"]
                pub fn ExecuteActionOnPlayingID(
                    in_ActionType: root::AK::SoundEngine::AkActionOnEventType,
                    in_playingID: root::AkPlayingID,
                    in_uTransitionDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine13SetRandomSeedEj"]
                pub fn SetRandomSeed(in_uSeed: root::AkUInt32);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine19MuteBackgroundMusicEb"]
                pub fn MuteBackgroundMusic(in_bMute: bool);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine22GetBackgroundMusicMuteEv"]
                pub fn GetBackgroundMusicMute() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine24SendPluginCustomGameDataEjy12AkPluginTypejjPKvj"]
                pub fn SendPluginCustomGameData(
                    in_busID: root::AkUniqueID,
                    in_busObjectID: root::AkGameObjectID,
                    in_eType: root::AkPluginType,
                    in_uCompanyID: root::AkUInt32,
                    in_uPluginID: root::AkUInt32,
                    in_pData: *const ::std::os::raw::c_void,
                    in_uSizeInBytes: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine15RegisterGameObjEy"]
                pub fn RegisterGameObj(in_gameObjectID: root::AkGameObjectID) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine15RegisterGameObjEyPKc"]
                pub fn RegisterGameObj1(
                    in_gameObjectID: root::AkGameObjectID,
                    in_pszObjName: *const ::std::os::raw::c_char,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine17UnregisterGameObjEy"]
                pub fn UnregisterGameObj(in_gameObjectID: root::AkGameObjectID) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine20UnregisterAllGameObjEv"]
                pub fn UnregisterAllGameObj() -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11SetPositionEyRK11AkTransform"]
                pub fn SetPosition(
                    in_GameObjectID: root::AkGameObjectID,
                    in_Position: *const root::AkSoundPosition,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine20SetMultiplePositionsEyPK11AkTransformtNS0_17MultiPositionTypeE"]
                pub fn SetMultiplePositions(
                    in_GameObjectID: root::AkGameObjectID,
                    in_pPositions: *const root::AkSoundPosition,
                    in_NumPositions: root::AkUInt16,
                    in_eMultiPositionType: root::AK::SoundEngine::MultiPositionType,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine20SetMultiplePositionsEyPK16AkChannelEmittertNS0_17MultiPositionTypeE"]
                pub fn SetMultiplePositions1(
                    in_GameObjectID: root::AkGameObjectID,
                    in_pPositions: *const root::AkChannelEmitter,
                    in_NumPositions: root::AkUInt16,
                    in_eMultiPositionType: root::AK::SoundEngine::MultiPositionType,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine16SetScalingFactorEyf"]
                pub fn SetScalingFactor(
                    in_GameObjectID: root::AkGameObjectID,
                    in_fAttenuationScalingFactor: root::AkReal32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine10ClearBanksEv"]
                pub fn ClearBanks() -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine21SetBankLoadIOSettingsEfa"]
                pub fn SetBankLoadIOSettings(
                    in_fThroughput: root::AkReal32,
                    in_priority: root::AkPriority,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8LoadBankEPKwRj"]
                pub fn LoadBank(
                    in_pszString: *const u32,
                    out_bankID: *mut root::AkBankID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8LoadBankEPKcRj"]
                pub fn LoadBank1(
                    in_pszString: *const ::std::os::raw::c_char,
                    out_bankID: *mut root::AkBankID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8LoadBankEj"]
                pub fn LoadBank2(in_bankID: root::AkBankID) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine18LoadBankMemoryViewEPKvjRj"]
                pub fn LoadBankMemoryView(
                    in_pInMemoryBankPtr: *const ::std::os::raw::c_void,
                    in_uInMemoryBankSize: root::AkUInt32,
                    out_bankID: *mut root::AkBankID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine18LoadBankMemoryCopyEPKvjRj"]
                pub fn LoadBankMemoryCopy(
                    in_pInMemoryBankPtr: *const ::std::os::raw::c_void,
                    in_uInMemoryBankSize: root::AkUInt32,
                    out_bankID: *mut root::AkBankID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine10DecodeBankEPKvjiRPvRj"]
                pub fn DecodeBank(
                    in_pInMemoryBankPtr: *const ::std::os::raw::c_void,
                    in_uInMemoryBankSize: root::AkUInt32,
                    in_uPoolForDecodedBank: root::AkMemPoolId,
                    out_pDecodedBankPtr: *mut *mut ::std::os::raw::c_void,
                    out_uDecodedBankSize: *mut root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8LoadBankEPKwPFvjPKv8AKRESULTPvES6_Rj"]
                pub fn LoadBank3(
                    in_pszString: *const u32,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                    out_bankID: *mut root::AkBankID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8LoadBankEPKcPFvjPKv8AKRESULTPvES6_Rj"]
                pub fn LoadBank4(
                    in_pszString: *const ::std::os::raw::c_char,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                    out_bankID: *mut root::AkBankID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8LoadBankEjPFvjPKv8AKRESULTPvES4_"]
                pub fn LoadBank5(
                    in_bankID: root::AkBankID,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine18LoadBankMemoryViewEPKvjPFvjS2_8AKRESULTPvES4_Rj"]
                pub fn LoadBankMemoryView1(
                    in_pInMemoryBankPtr: *const ::std::os::raw::c_void,
                    in_uInMemoryBankSize: root::AkUInt32,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                    out_bankID: *mut root::AkBankID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine18LoadBankMemoryCopyEPKvjPFvjS2_8AKRESULTPvES4_Rj"]
                pub fn LoadBankMemoryCopy1(
                    in_pInMemoryBankPtr: *const ::std::os::raw::c_void,
                    in_uInMemoryBankSize: root::AkUInt32,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                    out_bankID: *mut root::AkBankID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine10UnloadBankEPKwPKv"]
                pub fn UnloadBank(
                    in_pszString: *const u32,
                    in_pInMemoryBankPtr: *const ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine10UnloadBankEPKcPKv"]
                pub fn UnloadBank1(
                    in_pszString: *const ::std::os::raw::c_char,
                    in_pInMemoryBankPtr: *const ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine10UnloadBankEjPKv"]
                pub fn UnloadBank2(
                    in_bankID: root::AkBankID,
                    in_pInMemoryBankPtr: *const ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine10UnloadBankEPKwPKvPFvjS4_8AKRESULTPvES6_"]
                pub fn UnloadBank3(
                    in_pszString: *const u32,
                    in_pInMemoryBankPtr: *const ::std::os::raw::c_void,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine10UnloadBankEPKcPKvPFvjS4_8AKRESULTPvES6_"]
                pub fn UnloadBank4(
                    in_pszString: *const ::std::os::raw::c_char,
                    in_pInMemoryBankPtr: *const ::std::os::raw::c_void,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine10UnloadBankEjPKvPFvjS2_8AKRESULTPvES4_"]
                pub fn UnloadBank5(
                    in_bankID: root::AkBankID,
                    in_pInMemoryBankPtr: *const ::std::os::raw::c_void,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine24CancelBankCallbackCookieEPv"]
                pub fn CancelBankCallbackCookie(in_pCookie: *mut ::std::os::raw::c_void);
            }
            #[doc = "\\c PrepareEvent() will load required information to play the specified event."]
            pub const PreparationType_Preparation_Load: root::AK::SoundEngine::PreparationType = 0;
            #[doc = "\\c PrepareEvent() will unload required information to play the specified event."]
            pub const PreparationType_Preparation_Unload: root::AK::SoundEngine::PreparationType =
                1;
            #[doc = "Vorbis media is decoded when loading, and an uncompressed PCM version is used for playback."]
            pub const PreparationType_Preparation_LoadAndDecode:
                root::AK::SoundEngine::PreparationType = 2;
            #[doc = " Preparation type."]
            #[doc = " \\sa"]
            #[doc = " - <tt>AK::SoundEngine::PrepareEvent()</tt>"]
            #[doc = " - <tt>AK::SoundEngine::PrepareGameSyncs()</tt>"]
            #[doc = " - <tt>AK::SoundEngine::PrepareBank()</tt>"]
            pub type PreparationType = ::std::os::raw::c_uint;
            #[doc = "Use AkBankContent_StructureOnly to load only the structural content, including Events, and then later use the PrepareEvent() functions to load media on demand from loose files on the disk."]
            pub const AkBankContent_AkBankContent_StructureOnly:
                root::AK::SoundEngine::AkBankContent = 0;
            #[doc = "Use AkBankContent_All to load both the media and structural content."]
            pub const AkBankContent_AkBankContent_All: root::AK::SoundEngine::AkBankContent = 1;
            #[doc = " Parameter to be passed to <tt>AK::SoundEngine::PrepareBank()</tt>."]
            #[doc = " Use AkBankContent_All to load both the media and structural content from the bank."]
            #[doc = " Use AkBankContent_StructureOnly to load only the structural content, including events, from the bank and then later use the PrepareEvent() functions to load media on demand from loose files on the disk."]
            #[doc = " \\sa"]
            #[doc = " - <tt>AK::SoundEngine::PrepareBank()</tt>"]
            #[doc = " - \\ref soundengine_banks_preparingbanks"]
            pub type AkBankContent = ::std::os::raw::c_uint;
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11PrepareBankENS0_15PreparationTypeEPKwNS0_13AkBankContentE"]
                pub fn PrepareBank(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_pszString: *const u32,
                    in_uFlags: root::AK::SoundEngine::AkBankContent,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11PrepareBankENS0_15PreparationTypeEPKcNS0_13AkBankContentE"]
                pub fn PrepareBank1(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_pszString: *const ::std::os::raw::c_char,
                    in_uFlags: root::AK::SoundEngine::AkBankContent,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11PrepareBankENS0_15PreparationTypeEjNS0_13AkBankContentE"]
                pub fn PrepareBank2(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_bankID: root::AkBankID,
                    in_uFlags: root::AK::SoundEngine::AkBankContent,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11PrepareBankENS0_15PreparationTypeEPKwPFvjPKv8AKRESULTPvES7_NS0_13AkBankContentE"]
                pub fn PrepareBank3(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_pszString: *const u32,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                    in_uFlags: root::AK::SoundEngine::AkBankContent,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11PrepareBankENS0_15PreparationTypeEPKcPFvjPKv8AKRESULTPvES7_NS0_13AkBankContentE"]
                pub fn PrepareBank4(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_pszString: *const ::std::os::raw::c_char,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                    in_uFlags: root::AK::SoundEngine::AkBankContent,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11PrepareBankENS0_15PreparationTypeEjPFvjPKv8AKRESULTPvES5_NS0_13AkBankContentE"]
                pub fn PrepareBank5(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_bankID: root::AkBankID,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                    in_uFlags: root::AK::SoundEngine::AkBankContent,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine19ClearPreparedEventsEv"]
                pub fn ClearPreparedEvents() -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12PrepareEventENS0_15PreparationTypeEPPKwj"]
                pub fn PrepareEvent(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_ppszString: *mut *const u32,
                    in_uNumEvent: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12PrepareEventENS0_15PreparationTypeEPPKcj"]
                pub fn PrepareEvent1(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_ppszString: *mut *const ::std::os::raw::c_char,
                    in_uNumEvent: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12PrepareEventENS0_15PreparationTypeEPjj"]
                pub fn PrepareEvent2(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_pEventID: *mut root::AkUniqueID,
                    in_uNumEvent: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12PrepareEventENS0_15PreparationTypeEPPKwjPFvjPKv8AKRESULTPvES8_"]
                pub fn PrepareEvent3(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_ppszString: *mut *const u32,
                    in_uNumEvent: root::AkUInt32,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12PrepareEventENS0_15PreparationTypeEPPKcjPFvjPKv8AKRESULTPvES8_"]
                pub fn PrepareEvent4(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_ppszString: *mut *const ::std::os::raw::c_char,
                    in_uNumEvent: root::AkUInt32,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12PrepareEventENS0_15PreparationTypeEPjjPFvjPKv8AKRESULTPvES6_"]
                pub fn PrepareEvent5(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_pEventID: *mut root::AkUniqueID,
                    in_uNumEvent: root::AkUInt32,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8SetMediaEP16AkSourceSettingsj"]
                pub fn SetMedia(
                    in_pSourceSettings: *mut root::AkSourceSettings,
                    in_uNumSourceSettings: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine10UnsetMediaEP16AkSourceSettingsj"]
                pub fn UnsetMedia(
                    in_pSourceSettings: *mut root::AkSourceSettings,
                    in_uNumSourceSettings: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine13TryUnsetMediaEP16AkSourceSettingsjP8AKRESULT"]
                pub fn TryUnsetMedia(
                    in_pSourceSettings: *mut root::AkSourceSettings,
                    in_uNumSourceSettings: root::AkUInt32,
                    out_pUnsetResults: *mut root::AKRESULT,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine16PrepareGameSyncsENS0_15PreparationTypeE11AkGroupTypePKwPS4_j"]
                pub fn PrepareGameSyncs(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_eGameSyncType: root::AkGroupType,
                    in_pszGroupName: *const u32,
                    in_ppszGameSyncName: *mut *const u32,
                    in_uNumGameSyncs: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine16PrepareGameSyncsENS0_15PreparationTypeE11AkGroupTypePKcPS4_j"]
                pub fn PrepareGameSyncs1(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_eGameSyncType: root::AkGroupType,
                    in_pszGroupName: *const ::std::os::raw::c_char,
                    in_ppszGameSyncName: *mut *const ::std::os::raw::c_char,
                    in_uNumGameSyncs: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine16PrepareGameSyncsENS0_15PreparationTypeE11AkGroupTypejPjj"]
                pub fn PrepareGameSyncs2(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_eGameSyncType: root::AkGroupType,
                    in_GroupID: root::AkUInt32,
                    in_paGameSyncID: *mut root::AkUInt32,
                    in_uNumGameSyncs: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine16PrepareGameSyncsENS0_15PreparationTypeE11AkGroupTypePKwPS4_jPFvjPKv8AKRESULTPvES9_"]
                pub fn PrepareGameSyncs3(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_eGameSyncType: root::AkGroupType,
                    in_pszGroupName: *const u32,
                    in_ppszGameSyncName: *mut *const u32,
                    in_uNumGameSyncs: root::AkUInt32,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine16PrepareGameSyncsENS0_15PreparationTypeE11AkGroupTypePKcPS4_jPFvjPKv8AKRESULTPvES9_"]
                pub fn PrepareGameSyncs4(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_eGameSyncType: root::AkGroupType,
                    in_pszGroupName: *const ::std::os::raw::c_char,
                    in_ppszGameSyncName: *mut *const ::std::os::raw::c_char,
                    in_uNumGameSyncs: root::AkUInt32,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine16PrepareGameSyncsENS0_15PreparationTypeE11AkGroupTypejPjjPFvjPKv8AKRESULTPvES7_"]
                pub fn PrepareGameSyncs5(
                    in_PreparationType: root::AK::SoundEngine::PreparationType,
                    in_eGameSyncType: root::AkGroupType,
                    in_GroupID: root::AkUInt32,
                    in_paGameSyncID: *mut root::AkUInt32,
                    in_uNumGameSyncs: root::AkUInt32,
                    in_pfnBankCallback: root::AkBankCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetListenersEyPKyj"]
                pub fn SetListeners(
                    in_emitterGameObj: root::AkGameObjectID,
                    in_pListenerGameObjs: *const root::AkGameObjectID,
                    in_uNumListeners: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11AddListenerEyy"]
                pub fn AddListener(
                    in_emitterGameObj: root::AkGameObjectID,
                    in_listenerGameObj: root::AkGameObjectID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine14RemoveListenerEyy"]
                pub fn RemoveListener(
                    in_emitterGameObj: root::AkGameObjectID,
                    in_listenerGameObj: root::AkGameObjectID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine19SetDefaultListenersEPKyj"]
                pub fn SetDefaultListeners(
                    in_pListenerObjs: *const root::AkGameObjectID,
                    in_uNumListeners: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine18AddDefaultListenerEy"]
                pub fn AddDefaultListener(
                    in_listenerGameObj: root::AkGameObjectID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine21RemoveDefaultListenerEy"]
                pub fn RemoveDefaultListener(
                    in_listenerGameObj: root::AkGameObjectID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine23ResetListenersToDefaultEy"]
                pub fn ResetListenersToDefault(
                    in_emitterGameObj: root::AkGameObjectID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine25SetListenerSpatializationEyb15AkChannelConfigPf"]
                pub fn SetListenerSpatialization(
                    in_uListenerID: root::AkGameObjectID,
                    in_bSpatialized: bool,
                    in_channelConfig: root::AkChannelConfig,
                    in_pVolumeOffsets: root::AK::SpeakerVolumes::VectorPtr,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetRTPCValueEjfyi20AkCurveInterpolationb"]
                pub fn SetRTPCValue(
                    in_rtpcID: root::AkRtpcID,
                    in_value: root::AkRtpcValue,
                    in_gameObjectID: root::AkGameObjectID,
                    in_uValueChangeDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                    in_bBypassInternalValueInterpolation: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetRTPCValueEPKwfyi20AkCurveInterpolationb"]
                pub fn SetRTPCValue1(
                    in_pszRtpcName: *const u32,
                    in_value: root::AkRtpcValue,
                    in_gameObjectID: root::AkGameObjectID,
                    in_uValueChangeDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                    in_bBypassInternalValueInterpolation: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetRTPCValueEPKcfyi20AkCurveInterpolationb"]
                pub fn SetRTPCValue2(
                    in_pszRtpcName: *const ::std::os::raw::c_char,
                    in_value: root::AkRtpcValue,
                    in_gameObjectID: root::AkGameObjectID,
                    in_uValueChangeDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                    in_bBypassInternalValueInterpolation: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine23SetRTPCValueByPlayingIDEjfji20AkCurveInterpolationb"]
                pub fn SetRTPCValueByPlayingID(
                    in_rtpcID: root::AkRtpcID,
                    in_value: root::AkRtpcValue,
                    in_playingID: root::AkPlayingID,
                    in_uValueChangeDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                    in_bBypassInternalValueInterpolation: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine23SetRTPCValueByPlayingIDEPKwfji20AkCurveInterpolationb"]
                pub fn SetRTPCValueByPlayingID1(
                    in_pszRtpcName: *const u32,
                    in_value: root::AkRtpcValue,
                    in_playingID: root::AkPlayingID,
                    in_uValueChangeDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                    in_bBypassInternalValueInterpolation: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine23SetRTPCValueByPlayingIDEPKcfji20AkCurveInterpolationb"]
                pub fn SetRTPCValueByPlayingID2(
                    in_pszRtpcName: *const ::std::os::raw::c_char,
                    in_value: root::AkRtpcValue,
                    in_playingID: root::AkPlayingID,
                    in_uValueChangeDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                    in_bBypassInternalValueInterpolation: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine14ResetRTPCValueEjyi20AkCurveInterpolationb"]
                pub fn ResetRTPCValue(
                    in_rtpcID: root::AkRtpcID,
                    in_gameObjectID: root::AkGameObjectID,
                    in_uValueChangeDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                    in_bBypassInternalValueInterpolation: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine14ResetRTPCValueEPKwyi20AkCurveInterpolationb"]
                pub fn ResetRTPCValue1(
                    in_pszRtpcName: *const u32,
                    in_gameObjectID: root::AkGameObjectID,
                    in_uValueChangeDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                    in_bBypassInternalValueInterpolation: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine14ResetRTPCValueEPKcyi20AkCurveInterpolationb"]
                pub fn ResetRTPCValue2(
                    in_pszRtpcName: *const ::std::os::raw::c_char,
                    in_gameObjectID: root::AkGameObjectID,
                    in_uValueChangeDuration: root::AkTimeMs,
                    in_eFadeCurve: root::AkCurveInterpolation,
                    in_bBypassInternalValueInterpolation: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine9SetSwitchEjjy"]
                pub fn SetSwitch(
                    in_switchGroup: root::AkSwitchGroupID,
                    in_switchState: root::AkSwitchStateID,
                    in_gameObjectID: root::AkGameObjectID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine9SetSwitchEPKwS2_y"]
                pub fn SetSwitch1(
                    in_pszSwitchGroup: *const u32,
                    in_pszSwitchState: *const u32,
                    in_gameObjectID: root::AkGameObjectID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine9SetSwitchEPKcS2_y"]
                pub fn SetSwitch2(
                    in_pszSwitchGroup: *const ::std::os::raw::c_char,
                    in_pszSwitchState: *const ::std::os::raw::c_char,
                    in_gameObjectID: root::AkGameObjectID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11PostTriggerEjy"]
                pub fn PostTrigger(
                    in_triggerID: root::AkTriggerID,
                    in_gameObjectID: root::AkGameObjectID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11PostTriggerEPKwy"]
                pub fn PostTrigger1(
                    in_pszTrigger: *const u32,
                    in_gameObjectID: root::AkGameObjectID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11PostTriggerEPKcy"]
                pub fn PostTrigger2(
                    in_pszTrigger: *const ::std::os::raw::c_char,
                    in_gameObjectID: root::AkGameObjectID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8SetStateEjj"]
                pub fn SetState(
                    in_stateGroup: root::AkStateGroupID,
                    in_state: root::AkStateID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8SetStateEPKwS2_"]
                pub fn SetState1(
                    in_pszStateGroup: *const u32,
                    in_pszState: *const u32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8SetStateEPKcS2_"]
                pub fn SetState2(
                    in_pszStateGroup: *const ::std::os::raw::c_char,
                    in_pszState: *const ::std::os::raw::c_char,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine26SetGameObjectAuxSendValuesEyP14AkAuxSendValuej"]
                pub fn SetGameObjectAuxSendValues(
                    in_gameObjectID: root::AkGameObjectID,
                    in_aAuxSendValues: *mut root::AkAuxSendValue,
                    in_uNumSendValues: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine25RegisterBusVolumeCallbackEjPFvP33AkSpeakerVolumeMatrixCallbackInfoEPv"]
                pub fn RegisterBusVolumeCallback(
                    in_busID: root::AkUniqueID,
                    in_pfnCallback: root::AkBusCallbackFunc,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine27RegisterBusMeteringCallbackEjPFvP25AkBusMeteringCallbackInfoE15AkMeteringFlagsPv"]
                pub fn RegisterBusMeteringCallback(
                    in_busID: root::AkUniqueID,
                    in_pfnCallback: root::AkBusMeteringCallbackFunc,
                    in_eMeteringFlags: root::AkMeteringFlags,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine36RegisterOutputDeviceMeteringCallbackEyPFvP34AkOutputDeviceMeteringCallbackInfoE15AkMeteringFlagsPv"]
                pub fn RegisterOutputDeviceMeteringCallback(
                    in_idOutput: root::AkOutputDeviceID,
                    in_pfnCallback: root::AkOutputDeviceMeteringCallbackFunc,
                    in_eMeteringFlags: root::AkMeteringFlags,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine28SetGameObjectOutputBusVolumeEyyf"]
                pub fn SetGameObjectOutputBusVolume(
                    in_emitterObjID: root::AkGameObjectID,
                    in_listenerObjID: root::AkGameObjectID,
                    in_fControlValue: root::AkReal32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine19SetActorMixerEffectEjjj"]
                pub fn SetActorMixerEffect(
                    in_audioNodeID: root::AkUniqueID,
                    in_uFXIndex: root::AkUInt32,
                    in_shareSetID: root::AkUniqueID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetBusEffectEjjj"]
                pub fn SetBusEffect(
                    in_audioNodeID: root::AkUniqueID,
                    in_uFXIndex: root::AkUInt32,
                    in_shareSetID: root::AkUniqueID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetBusEffectEPKwjj"]
                pub fn SetBusEffect1(
                    in_pszBusName: *const u32,
                    in_uFXIndex: root::AkUInt32,
                    in_shareSetID: root::AkUniqueID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetBusEffectEPKcjj"]
                pub fn SetBusEffect2(
                    in_pszBusName: *const ::std::os::raw::c_char,
                    in_uFXIndex: root::AkUInt32,
                    in_shareSetID: root::AkUniqueID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine21SetOutputDeviceEffectEyjj"]
                pub fn SetOutputDeviceEffect(
                    in_outputDeviceID: root::AkOutputDeviceID,
                    in_uFXIndex: root::AkUInt32,
                    in_FXShareSetID: root::AkUniqueID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8SetMixerEjj"]
                pub fn SetMixer(
                    in_audioNodeID: root::AkUniqueID,
                    in_shareSetID: root::AkUniqueID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8SetMixerEPKwj"]
                pub fn SetMixer1(
                    in_pszBusName: *const u32,
                    in_shareSetID: root::AkUniqueID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine8SetMixerEPKcj"]
                pub fn SetMixer2(
                    in_pszBusName: *const ::std::os::raw::c_char,
                    in_shareSetID: root::AkUniqueID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetBusConfigEj15AkChannelConfig"]
                pub fn SetBusConfig(
                    in_audioNodeID: root::AkUniqueID,
                    in_channelConfig: root::AkChannelConfig,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetBusConfigEPKw15AkChannelConfig"]
                pub fn SetBusConfig1(
                    in_pszBusName: *const u32,
                    in_channelConfig: root::AkChannelConfig,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetBusConfigEPKc15AkChannelConfig"]
                pub fn SetBusConfig2(
                    in_pszBusName: *const ::std::os::raw::c_char,
                    in_channelConfig: root::AkChannelConfig,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine32SetObjectObstructionAndOcclusionEyyff"]
                pub fn SetObjectObstructionAndOcclusion(
                    in_EmitterID: root::AkGameObjectID,
                    in_ListenerID: root::AkGameObjectID,
                    in_fObstructionLevel: root::AkReal32,
                    in_fOcclusionLevel: root::AkReal32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine34SetMultipleObstructionAndOcclusionEyyP28AkObstructionOcclusionValuesj"]
                pub fn SetMultipleObstructionAndOcclusion(
                    in_EmitterID: root::AkGameObjectID,
                    in_uListenerID: root::AkGameObjectID,
                    in_fObstructionOcclusionValues: *mut root::AkObstructionOcclusionValues,
                    in_uNumOcclusionObstruction: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine19GetContainerHistoryEPNS_11IWriteBytesE"]
                pub fn GetContainerHistory(in_pBytes: *mut root::AK::IWriteBytes)
                    -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine19SetContainerHistoryEPNS_10IReadBytesE"]
                pub fn SetContainerHistory(in_pBytes: *mut root::AK::IReadBytes) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine18StartOutputCaptureEPKc"]
                pub fn StartOutputCapture(
                    in_CaptureFileName: *const root::AkOSChar,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine17StopOutputCaptureEv"]
                pub fn StopOutputCapture() -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine22AddOutputCaptureMarkerEPKc"]
                pub fn AddOutputCaptureMarker(
                    in_MarkerText: *const ::std::os::raw::c_char,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine13GetSampleRateEv"]
                pub fn GetSampleRate() -> root::AkUInt32;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine23RegisterCaptureCallbackEPFvR13AkAudioBufferyPvEyS3_"]
                pub fn RegisterCaptureCallback(
                    in_pfnCallback: root::AkCaptureCallbackFunc,
                    in_idOutput: root::AkOutputDeviceID,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine25UnregisterCaptureCallbackEPFvR13AkAudioBufferyPvEyS3_"]
                pub fn UnregisterCaptureCallback(
                    in_pfnCallback: root::AkCaptureCallbackFunc,
                    in_idOutput: root::AkOutputDeviceID,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine20StartProfilerCaptureEPKc"]
                pub fn StartProfilerCapture(
                    in_CaptureFileName: *const root::AkOSChar,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine19StopProfilerCaptureEv"]
                pub fn StopProfilerCapture() -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine28SetOfflineRenderingFrameTimeEf"]
                pub fn SetOfflineRenderingFrameTime(
                    in_fFrameTimeInSeconds: root::AkReal32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine19SetOfflineRenderingEb"]
                pub fn SetOfflineRendering(in_bEnableOfflineRendering: bool) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine9AddOutputERK16AkOutputSettingsPyPKyj"]
                pub fn AddOutput(
                    in_Settings: *const root::AkOutputSettings,
                    out_pDeviceID: *mut root::AkOutputDeviceID,
                    in_pListenerIDs: *const root::AkGameObjectID,
                    in_uNumListeners: root::AkUInt32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12RemoveOutputEy"]
                pub fn RemoveOutput(in_idOutput: root::AkOutputDeviceID) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine13ReplaceOutputERK16AkOutputSettingsyPy"]
                pub fn ReplaceOutput(
                    in_Settings: *const root::AkOutputSettings,
                    in_outputDeviceId: root::AkOutputDeviceID,
                    out_pOutputDeviceId: *mut root::AkOutputDeviceID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11GetOutputIDEjj"]
                pub fn GetOutputID(
                    in_idShareset: root::AkUniqueID,
                    in_idDevice: root::AkUInt32,
                ) -> root::AkOutputDeviceID;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11GetOutputIDEPKcj"]
                pub fn GetOutputID1(
                    in_szShareSet: *const ::std::os::raw::c_char,
                    in_idDevice: root::AkUInt32,
                ) -> root::AkOutputDeviceID;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine11GetOutputIDEPKwj"]
                pub fn GetOutputID2(
                    in_szShareSet: *const u32,
                    in_idDevice: root::AkUInt32,
                ) -> root::AkOutputDeviceID;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetBusDeviceEjj"]
                pub fn SetBusDevice(
                    in_idBus: root::AkUniqueID,
                    in_idNewDevice: root::AkUniqueID,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetBusDeviceEPKcS2_"]
                pub fn SetBusDevice1(
                    in_BusName: *const ::std::os::raw::c_char,
                    in_DeviceName: *const ::std::os::raw::c_char,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine12SetBusDeviceEPKwS2_"]
                pub fn SetBusDevice2(
                    in_BusName: *const u32,
                    in_DeviceName: *const u32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine13GetDeviceListEjjRjP19AkDeviceDescription"]
                pub fn GetDeviceList(
                    in_ulCompanyID: root::AkUInt32,
                    in_ulPluginID: root::AkUInt32,
                    io_maxNumDevices: *mut root::AkUInt32,
                    out_deviceDescriptions: *mut root::AkDeviceDescription,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine13GetDeviceListEjRjP19AkDeviceDescription"]
                pub fn GetDeviceList1(
                    in_audioDeviceShareSetID: root::AkUniqueID,
                    io_maxNumDevices: *mut root::AkUInt32,
                    out_deviceDescriptions: *mut root::AkDeviceDescription,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine15SetOutputVolumeEyf"]
                pub fn SetOutputVolume(
                    in_idOutput: root::AkOutputDeviceID,
                    in_fVolume: root::AkReal32,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine28GetDeviceSpatialAudioSupportEj"]
                pub fn GetDeviceSpatialAudioSupport(in_idDevice: root::AkUInt32) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine7SuspendEb"]
                pub fn Suspend(in_bRenderAnyway: bool) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine17WakeupFromSuspendEv"]
                pub fn WakeupFromSuspend() -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine13GetBufferTickEv"]
                pub fn GetBufferTick() -> root::AkUInt32;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11SoundEngine13GetSampleTickEv"]
                pub fn GetSampleTick() -> root::AkUInt64;
            }
            pub mod Query {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query11GetPositionEyR11AkTransform"]
                    pub fn GetPosition(
                        in_GameObjectID: root::AkGameObjectID,
                        out_rPosition: *mut root::AkSoundPosition,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query12GetListenersEyPyRj"]
                    pub fn GetListeners(
                        in_GameObjectID: root::AkGameObjectID,
                        out_ListenerObjectIDs: *mut root::AkGameObjectID,
                        oi_uNumListeners: *mut root::AkUInt32,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query19GetListenerPositionEyR11AkTransform"]
                    pub fn GetListenerPosition(
                        in_uIndex: root::AkGameObjectID,
                        out_rPosition: *mut root::AkListenerPosition,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query25GetListenerSpatializationEjRbRPfR15AkChannelConfig"]
                    pub fn GetListenerSpatialization(
                        in_uIndex: root::AkUInt32,
                        out_rbSpatialized: *mut bool,
                        out_pVolumeOffsets: *mut root::AK::SpeakerVolumes::VectorPtr,
                        out_channelConfig: *mut root::AkChannelConfig,
                    ) -> root::AKRESULT;
                }
                #[repr(u32)]
                #[doc = " Enum used to request a specific RTPC Value."]
                #[doc = " Also used to inform the user of where the RTPC Value comes from."]
                #[doc = ""]
                #[doc = " For example, the user may request the GameObject specific value by specifying RTPCValue_GameObject"]
                #[doc = " and can receive the Global Value if there was no GameObject specific value, and even the"]
                #[doc = " default value is there was no Global value either."]
                #[doc = " \\sa"]
                #[doc = " - GetRTPCValue"]
                #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
                pub enum RTPCValue_type {
                    #[doc = "The value is the Default RTPC."]
                    RTPCValue_Default = 0,
                    #[doc = "The value is the Global RTPC."]
                    RTPCValue_Global = 1,
                    #[doc = "The value is the game object specific RTPC."]
                    RTPCValue_GameObject = 2,
                    #[doc = "The value is the playing ID specific RTPC."]
                    RTPCValue_PlayingID = 3,
                    #[doc = "The value is not available for the RTPC specified."]
                    RTPCValue_Unavailable = 4,
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query12GetRTPCValueEjyjRfRNS1_14RTPCValue_typeE"]
                    pub fn GetRTPCValue(
                        in_rtpcID: root::AkRtpcID,
                        in_gameObjectID: root::AkGameObjectID,
                        in_playingID: root::AkPlayingID,
                        out_rValue: *mut root::AkRtpcValue,
                        io_rValueType: *mut root::AK::SoundEngine::Query::RTPCValue_type,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query12GetRTPCValueEPKwyjRfRNS1_14RTPCValue_typeE"]
                    pub fn GetRTPCValue1(
                        in_pszRtpcName: *const u32,
                        in_gameObjectID: root::AkGameObjectID,
                        in_playingID: root::AkPlayingID,
                        out_rValue: *mut root::AkRtpcValue,
                        io_rValueType: *mut root::AK::SoundEngine::Query::RTPCValue_type,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query12GetRTPCValueEPKcyjRfRNS1_14RTPCValue_typeE"]
                    pub fn GetRTPCValue2(
                        in_pszRtpcName: *const ::std::os::raw::c_char,
                        in_gameObjectID: root::AkGameObjectID,
                        in_playingID: root::AkPlayingID,
                        out_rValue: *mut root::AkRtpcValue,
                        io_rValueType: *mut root::AK::SoundEngine::Query::RTPCValue_type,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query9GetSwitchEjyRj"]
                    pub fn GetSwitch(
                        in_switchGroup: root::AkSwitchGroupID,
                        in_gameObjectID: root::AkGameObjectID,
                        out_rSwitchState: *mut root::AkSwitchStateID,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query9GetSwitchEPKwyRj"]
                    pub fn GetSwitch1(
                        in_pstrSwitchGroupName: *const u32,
                        in_GameObj: root::AkGameObjectID,
                        out_rSwitchState: *mut root::AkSwitchStateID,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query9GetSwitchEPKcyRj"]
                    pub fn GetSwitch2(
                        in_pstrSwitchGroupName: *const ::std::os::raw::c_char,
                        in_GameObj: root::AkGameObjectID,
                        out_rSwitchState: *mut root::AkSwitchStateID,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query8GetStateEjRj"]
                    pub fn GetState(
                        in_stateGroup: root::AkStateGroupID,
                        out_rState: *mut root::AkStateID,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query8GetStateEPKwRj"]
                    pub fn GetState1(
                        in_pstrStateGroupName: *const u32,
                        out_rState: *mut root::AkStateID,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query8GetStateEPKcRj"]
                    pub fn GetState2(
                        in_pstrStateGroupName: *const ::std::os::raw::c_char,
                        out_rState: *mut root::AkStateID,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query26GetGameObjectAuxSendValuesEyP14AkAuxSendValueRj"]
                    pub fn GetGameObjectAuxSendValues(
                        in_gameObjectID: root::AkGameObjectID,
                        out_paAuxSendValues: *mut root::AkAuxSendValue,
                        io_ruNumSendValues: *mut root::AkUInt32,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query26GetGameObjectDryLevelValueEyyRf"]
                    pub fn GetGameObjectDryLevelValue(
                        in_EmitterID: root::AkGameObjectID,
                        in_ListenerID: root::AkGameObjectID,
                        out_rfControlValue: *mut root::AkReal32,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query32GetObjectObstructionAndOcclusionEyyRfS2_"]
                    pub fn GetObjectObstructionAndOcclusion(
                        in_EmitterID: root::AkGameObjectID,
                        in_ListenerID: root::AkGameObjectID,
                        out_rfObstructionLevel: *mut root::AkReal32,
                        out_rfOcclusionLevel: *mut root::AkReal32,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query19QueryAudioObjectIDsEjRjP12AkObjectInfo"]
                    pub fn QueryAudioObjectIDs(
                        in_eventID: root::AkUniqueID,
                        io_ruNumItems: *mut root::AkUInt32,
                        out_aObjectInfos: *mut root::AkObjectInfo,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query19QueryAudioObjectIDsEPKwRjP12AkObjectInfo"]
                    pub fn QueryAudioObjectIDs1(
                        in_pszEventName: *const u32,
                        io_ruNumItems: *mut root::AkUInt32,
                        out_aObjectInfos: *mut root::AkObjectInfo,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query19QueryAudioObjectIDsEPKcRjP12AkObjectInfo"]
                    pub fn QueryAudioObjectIDs2(
                        in_pszEventName: *const ::std::os::raw::c_char,
                        io_ruNumItems: *mut root::AkUInt32,
                        out_aObjectInfos: *mut root::AkObjectInfo,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query18GetPositioningInfoEjR17AkPositioningInfo"]
                    pub fn GetPositioningInfo(
                        in_ObjectID: root::AkUniqueID,
                        out_rPositioningInfo: *mut root::AkPositioningInfo,
                    ) -> root::AKRESULT;
                }
                #[doc = " List passed to GetActiveGameObjects."]
                #[doc = " After calling this function, the list will contain the list of all game objects that are currently active in the sound engine."]
                #[doc = " Being active means that either a sound is playing or pending to be played using this game object."]
                #[doc = " The caller is responsible for calling Term() on the list when the list is not required anymore"]
                #[doc = " \\sa"]
                #[doc = " - GetActiveGameObjects"]
                pub type AkGameObjectsList = u8;
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query20GetActiveGameObjectsER7AkArrayIyy23AkArrayAllocatorNoAlignIL7AkMemID0EE27AkGrowByPolicy_Proportional22AkAssignmentMovePolicyIyEE"]
                    pub fn GetActiveGameObjects(
                        io_GameObjectList: *mut root::AK::SoundEngine::Query::AkGameObjectsList,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query21GetIsGameObjectActiveEy"]
                    pub fn GetIsGameObjectActive(in_GameObjId: root::AkGameObjectID) -> bool;
                }
                #[doc = " Game object and max distance association."]
                #[doc = " \\sa"]
                #[doc = " - \\ref AkRadiusList"]
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct GameObjDst {
                    #[doc = "Game object ID"]
                    pub m_gameObjID: root::AkGameObjectID,
                    #[doc = "MaxDistance"]
                    pub m_dst: root::AkReal32,
                }
                #[doc = " List passed to GetMaxRadius."]
                #[doc = " \\sa"]
                #[doc = " - \\ref AK::SoundEngine::Query::GetMaxRadius"]
                pub type AkRadiusList = u8;
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query12GetMaxRadiusER7AkArrayINS1_10GameObjDstERKS3_23AkArrayAllocatorNoAlignIL7AkMemID0EE27AkGrowByPolicy_Proportional22AkAssignmentMovePolicyIS3_EE"]
                    pub fn GetMaxRadius(
                        io_RadiusList: *mut root::AK::SoundEngine::Query::AkRadiusList,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query12GetMaxRadiusEy"]
                    pub fn GetMaxRadius1(in_GameObjId: root::AkGameObjectID) -> root::AkReal32;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query23GetEventIDFromPlayingIDEj"]
                    pub fn GetEventIDFromPlayingID(
                        in_playingID: root::AkPlayingID,
                    ) -> root::AkUniqueID;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query26GetGameObjectFromPlayingIDEj"]
                    pub fn GetGameObjectFromPlayingID(
                        in_playingID: root::AkPlayingID,
                    ) -> root::AkGameObjectID;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query27GetPlayingIDsFromGameObjectEyRjPj"]
                    pub fn GetPlayingIDsFromGameObject(
                        in_GameObjId: root::AkGameObjectID,
                        io_ruNumIDs: *mut root::AkUInt32,
                        out_aPlayingIDs: *mut root::AkPlayingID,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query22GetCustomPropertyValueEjjRi"]
                    pub fn GetCustomPropertyValue(
                        in_ObjectID: root::AkUniqueID,
                        in_uPropID: root::AkUInt32,
                        out_iValue: *mut root::AkInt32,
                    ) -> root::AKRESULT;
                }
                extern "C" {
                    #[link_name = "\u{1}__ZN2AK11SoundEngine5Query22GetCustomPropertyValueEjjRf"]
                    pub fn GetCustomPropertyValue1(
                        in_ObjectID: root::AkUniqueID,
                        in_uPropID: root::AkUInt32,
                        out_fValue: *mut root::AkReal32,
                    ) -> root::AKRESULT;
                }
            }
        }
        pub const AkChannelOrdering_ChannelOrdering_Standard: root::AK::AkChannelOrdering = 0;
        pub const AkChannelOrdering_ChannelOrdering_RunTime: root::AK::AkChannelOrdering = 1;
        #[doc = " Channel ordering type."]
        pub type AkChannelOrdering = ::std::os::raw::c_uint;
        pub mod SpeakerVolumes {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod Vector {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            pub type VectorPtr = *mut root::AkReal32;
            pub type MatrixPtr = *mut root::AkReal32;
            pub type ConstVectorPtr = *const root::AkReal32;
            pub type ConstMatrixPtr = *const root::AkReal32;
            pub mod Matrix {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
        }
        extern "C" {
            #[link_name = "\u{1}__ZN2AK12g_fFreqRatioE"]
            pub static mut g_fFreqRatio: root::AkReal32;
        }
        pub mod MemoryMgr {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[doc = " Memory category statistics."]
            #[doc = " \\remarks These statistics are not collected in the Release configuration of"]
            #[doc = " the default memory manager implementation."]
            #[doc = " \\sa"]
            #[doc = " - AK::MemoryMgr::GetCategoryStats()"]
            #[doc = " - \\ref memorymanager"]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct CategoryStats {
                #[doc = "Used memory (in bytes)"]
                pub uUsed: root::AkUInt64,
                #[doc = "Peak used memory (in bytes)"]
                pub uPeakUsed: root::AkUInt64,
                #[doc = "Number of allocation calls since initialization"]
                pub uAllocs: root::AkUInt32,
                #[doc = "Number of free calls since initialization"]
                pub uFrees: root::AkUInt32,
            }
            #[doc = " Memory global statistics."]
            #[doc = " \\remarks These statistics are not collected in the Release configuration of"]
            #[doc = " the default memory manager implementation."]
            #[doc = " \\sa"]
            #[doc = " - AK::MemoryMgr::GetGlobalStats()"]
            #[doc = " - \\ref memorymanager"]
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct GlobalStats {
                #[doc = "Total memory used including all categories (in bytes)"]
                pub uUsed: root::AkUInt64,
                #[doc = "Total device memory used including all categories (in bytes)"]
                pub uDeviceUsed: root::AkUInt64,
                #[doc = "Total reserved memory. (Used and unused). Will return 0 if the reserved memory is not traceable."]
                pub uReserved: root::AkUInt64,
                #[doc = "Maximum total allocation size, specified in the initialization settings through uMemAllocationSizeLimit. Will be 0 if no limit was set."]
                pub uMax: root::AkUInt64,
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr13IsInitializedEv"]
                pub fn IsInitialized() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr4TermEv"]
                pub fn Term();
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr13InitForThreadEv"]
                pub fn InitForThread();
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr13TermForThreadEv"]
                pub fn TermForThread();
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr7dMallocEimPKcj"]
                pub fn dMalloc(
                    in_poolId: root::AkMemPoolId,
                    in_uSize: root::size_t,
                    in_pszFile: *const ::std::os::raw::c_char,
                    in_uLine: root::AkUInt32,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr6MallocEim"]
                pub fn Malloc(
                    in_poolId: root::AkMemPoolId,
                    in_uSize: root::size_t,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr8dReallocEiPvmPKcj"]
                pub fn dRealloc(
                    in_poolId: root::AkMemPoolId,
                    in_pAlloc: *mut ::std::os::raw::c_void,
                    in_uSize: root::size_t,
                    in_pszFile: *const ::std::os::raw::c_char,
                    in_uLine: root::AkUInt32,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr7ReallocEiPvm"]
                pub fn Realloc(
                    in_poolId: root::AkMemPoolId,
                    in_pAlloc: *mut ::std::os::raw::c_void,
                    in_uSize: root::size_t,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr15dReallocAlignedEiPvmjPKcj"]
                pub fn dReallocAligned(
                    in_poolId: root::AkMemPoolId,
                    in_pAlloc: *mut ::std::os::raw::c_void,
                    in_uSize: root::size_t,
                    in_uAlignment: root::AkUInt32,
                    in_pszFile: *const ::std::os::raw::c_char,
                    in_uLine: root::AkUInt32,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr14ReallocAlignedEiPvmj"]
                pub fn ReallocAligned(
                    in_poolId: root::AkMemPoolId,
                    in_pAlloc: *mut ::std::os::raw::c_void,
                    in_uSize: root::size_t,
                    in_uAlignment: root::AkUInt32,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr4FreeEiPv"]
                pub fn Free(
                    in_poolId: root::AkMemPoolId,
                    in_pMemAddress: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr7dMalignEimjPKcj"]
                pub fn dMalign(
                    in_poolId: root::AkMemPoolId,
                    in_uSize: root::size_t,
                    in_uAlignment: root::AkUInt32,
                    in_pszFile: *const ::std::os::raw::c_char,
                    in_uLine: root::AkUInt32,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr6MalignEimj"]
                pub fn Malign(
                    in_poolId: root::AkMemPoolId,
                    in_uSize: root::size_t,
                    in_uAlignment: root::AkUInt32,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr16GetCategoryStatsEiRNS0_13CategoryStatsE"]
                pub fn GetCategoryStats(
                    in_poolId: root::AkMemPoolId,
                    out_poolStats: *mut root::AK::MemoryMgr::CategoryStats,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr14GetGlobalStatsERNS0_11GlobalStatsE"]
                pub fn GetGlobalStats(out_stats: *mut root::AK::MemoryMgr::GlobalStats);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr23StartProfileThreadUsageEv"]
                pub fn StartProfileThreadUsage();
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr22StopProfileThreadUsageEv"]
                pub fn StopProfileThreadUsage() -> root::AkUInt64;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr10DumpToFileEPKc"]
                pub fn DumpToFile(pszFilename: *const root::AkOSChar);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr4InitEP13AkMemSettings"]
                pub fn Init(in_pSettings: *mut root::AkMemSettings) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr18GetDefaultSettingsER13AkMemSettings"]
                pub fn GetDefaultSettings(out_pMemSettings: *mut root::AkMemSettings);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr27AkCrtAllocatorInitForThreadEv"]
                pub fn AkCrtAllocatorInitForThread();
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr27AkCrtAllocatorTermForThreadEv"]
                pub fn AkCrtAllocatorTermForThread();
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr20AkCrtAllocatorMallocEim"]
                pub fn AkCrtAllocatorMalloc(
                    poolId: root::AkMemPoolId,
                    uSize: root::size_t,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr20AkCrtAllocatorMalignEimj"]
                pub fn AkCrtAllocatorMalign(
                    poolId: root::AkMemPoolId,
                    uSize: root::size_t,
                    uAlignment: root::AkUInt32,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr21AkCrtAllocatorReallocEiPvm"]
                pub fn AkCrtAllocatorRealloc(
                    poolId: root::AkMemPoolId,
                    pAddress: *mut ::std::os::raw::c_void,
                    uSize: root::size_t,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr28AkCrtAllocatorReallocAlignedEiPvmj"]
                pub fn AkCrtAllocatorReallocAligned(
                    poolId: root::AkMemPoolId,
                    pAddress: *mut ::std::os::raw::c_void,
                    uSize: root::size_t,
                    uAlignment: root::AkUInt32,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr18AkCrtAllocatorFreeEiPv"]
                pub fn AkCrtAllocatorFree(
                    poolId: root::AkMemPoolId,
                    pAddress: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr37AkCrtAllocatorTotalReservedMemorySizeEv"]
                pub fn AkCrtAllocatorTotalReservedMemorySize() -> root::size_t;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr26AkCrtAllocatorSizeOfMemoryEiPv"]
                pub fn AkCrtAllocatorSizeOfMemory(
                    poolID: root::AkMemPoolId,
                    pAddress: *mut ::std::os::raw::c_void,
                ) -> root::size_t;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr29AkStompAllocatorInitForThreadEv"]
                pub fn AkStompAllocatorInitForThread();
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr29AkStompAllocatorTermForThreadEv"]
                pub fn AkStompAllocatorTermForThread();
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr22AkStompAllocatorMallocEim"]
                pub fn AkStompAllocatorMalloc(
                    poolId: root::AkMemPoolId,
                    uSize: root::size_t,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr22AkStompAllocatorMalignEimj"]
                pub fn AkStompAllocatorMalign(
                    poolId: root::AkMemPoolId,
                    uSize: root::size_t,
                    uAlignment: root::AkUInt32,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr23AkStompAllocatorReallocEiPvm"]
                pub fn AkStompAllocatorRealloc(
                    poolId: root::AkMemPoolId,
                    pAddress: *mut ::std::os::raw::c_void,
                    uSize: root::size_t,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr30AkStompAllocatorReallocAlignedEiPvmj"]
                pub fn AkStompAllocatorReallocAligned(
                    poolId: root::AkMemPoolId,
                    pAddress: *mut ::std::os::raw::c_void,
                    uSize: root::size_t,
                    uAlignment: root::AkUInt32,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr20AkStompAllocatorFreeEiPv"]
                pub fn AkStompAllocatorFree(
                    poolId: root::AkMemPoolId,
                    pAddress: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr39AkStompAllocatorTotalReservedMemorySizeEv"]
                pub fn AkStompAllocatorTotalReservedMemorySize() -> root::size_t;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr28AkStompAllocatorSizeOfMemoryEiPv"]
                pub fn AkStompAllocatorSizeOfMemory(
                    poolID: root::AkMemPoolId,
                    pAddress: *mut ::std::os::raw::c_void,
                ) -> root::size_t;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr18AkMemDebugToolInitEv"]
                pub fn AkMemDebugToolInit() -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr18AkMemDebugToolTermEv"]
                pub fn AkMemDebugToolTerm();
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr20AkMemDebugToolMallocEimPvPKcj"]
                pub fn AkMemDebugToolMalloc(
                    poolId: root::AkMemPoolId,
                    uSize: root::size_t,
                    pAddress: *mut ::std::os::raw::c_void,
                    pszFile: *const ::std::os::raw::c_char,
                    uLine: root::AkUInt32,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr20AkMemDebugToolMalignEimjPvPKcj"]
                pub fn AkMemDebugToolMalign(
                    poolId: root::AkMemPoolId,
                    uSize: root::size_t,
                    uAlignment: root::AkUInt32,
                    pAddress: *mut ::std::os::raw::c_void,
                    pszFile: *const ::std::os::raw::c_char,
                    uLine: root::AkUInt32,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr21AkMemDebugToolReallocEiPvmS1_PKcj"]
                pub fn AkMemDebugToolRealloc(
                    poolId: root::AkMemPoolId,
                    pOldAddress: *mut ::std::os::raw::c_void,
                    uSize: root::size_t,
                    pNewAddress: *mut ::std::os::raw::c_void,
                    pszFile: *const ::std::os::raw::c_char,
                    uLine: root::AkUInt32,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr28AkMemDebugToolReallocAlignedEiPvmjS1_PKcj"]
                pub fn AkMemDebugToolReallocAligned(
                    poolId: root::AkMemPoolId,
                    pOldAddress: *mut ::std::os::raw::c_void,
                    uSize: root::size_t,
                    uAlignment: root::AkUInt32,
                    pNewAddress: *mut ::std::os::raw::c_void,
                    pszFile: *const ::std::os::raw::c_char,
                    uLine: root::AkUInt32,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9MemoryMgr18AkMemDebugToolFreeEiPv"]
                pub fn AkMemDebugToolFree(
                    poolId: root::AkMemPoolId,
                    pAddress: *mut ::std::os::raw::c_void,
                );
            }
        }
        #[repr(C)]
        pub struct IAkPluginMemAlloc__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Interface to memory allocation"]
        #[doc = " \\akcaution SDK users should never call these function directly, but use memory allocation macros instead. \\endakcaution"]
        #[doc = " \\sa"]
        #[doc = " - \\ref fx_memory_alloc"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkPluginMemAlloc {
            pub vtable_: *const IAkPluginMemAlloc__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Hash32 {
            pub _address: u8,
        }
        pub type Hash32_HashType = ::std::os::raw::c_uint;
        pub type Hash32_SizeType = ::std::os::raw::c_uint;
        pub const Hash32_s_offsetBasis: root::AK::Hash32_HashType = 2166136261;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Hash30 {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Hash64 {
            pub _address: u8,
        }
        pub type Hash64_HashType = ::std::os::raw::c_ulonglong;
        pub type Hash64_SizeType = ::std::os::raw::c_ulonglong;
        pub const Hash64_s_offsetBasis: root::AK::Hash64_HashType = 14695981039346656037;
        #[repr(C)]
        pub struct FNVHash {
            pub m_uHash: [u8; 0usize],
        }
        pub type FNVHash32 = root::AK::FNVHash;
        pub type FNVHash30 = root::AK::FNVHash;
        pub type FNVHash64 = root::AK::FNVHash;
        #[repr(C)]
        pub struct IAkMetering__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Interface to retrieve metering information about a buffer."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkMetering {
            pub vtable_: *const IAkMetering__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IAkRTPCSubscriber__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Real-Time Parameter Control Subscriber interface."]
        #[doc = " This interface must be implemented by every AK::IAkPluginParam implementation, allowing"]
        #[doc = " real-time editing with Wwise and in-game RTPC control."]
        #[doc = " \\akwarning"]
        #[doc = " The functions in this interface are not thread-safe, unless stated otherwise."]
        #[doc = " \\endakwarning"]
        #[doc = " \\sa"]
        #[doc = " - AK::IAkPluginParam"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkRTPCSubscriber {
            pub vtable_: *const IAkRTPCSubscriber__bindgen_vtable,
        }
        pub mod Monitor {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub const ErrorLevel_ErrorLevel_Message: root::AK::Monitor::ErrorLevel = 1;
            pub const ErrorLevel_ErrorLevel_Error: root::AK::Monitor::ErrorLevel = 2;
            pub const ErrorLevel_ErrorLevel_All: root::AK::Monitor::ErrorLevel = 3;
            #[doc = "  ErrorLevel"]
            pub type ErrorLevel = ::std::os::raw::c_uint;
            pub const ErrorCode_ErrorCode_NoError: root::AK::Monitor::ErrorCode = 0;
            pub const ErrorCode_ErrorCode_FileNotFound: root::AK::Monitor::ErrorCode = 1;
            pub const ErrorCode_ErrorCode_CannotOpenFile: root::AK::Monitor::ErrorCode = 2;
            pub const ErrorCode_ErrorCode_CannotStartStreamNoMemory: root::AK::Monitor::ErrorCode =
                3;
            pub const ErrorCode_ErrorCode_IODevice: root::AK::Monitor::ErrorCode = 4;
            pub const ErrorCode_ErrorCode_IncompatibleIOSettings: root::AK::Monitor::ErrorCode = 5;
            pub const ErrorCode_ErrorCode_PluginUnsupportedChannelConfiguration:
                root::AK::Monitor::ErrorCode = 6;
            pub const ErrorCode_ErrorCode_PluginMediaUnavailable: root::AK::Monitor::ErrorCode = 7;
            pub const ErrorCode_ErrorCode_PluginInitialisationFailed: root::AK::Monitor::ErrorCode =
                8;
            pub const ErrorCode_ErrorCode_PluginProcessingFailed: root::AK::Monitor::ErrorCode = 9;
            pub const ErrorCode_ErrorCode_PluginExecutionInvalid: root::AK::Monitor::ErrorCode = 10;
            pub const ErrorCode_ErrorCode_PluginAllocationFailed: root::AK::Monitor::ErrorCode = 11;
            pub const ErrorCode_ErrorCode_VorbisSeekTableRecommended: root::AK::Monitor::ErrorCode =
                12;
            pub const ErrorCode_ErrorCode_VorbisDecodeError: root::AK::Monitor::ErrorCode = 13;
            pub const ErrorCode_ErrorCode_AACDecodeError: root::AK::Monitor::ErrorCode = 14;
            pub const ErrorCode_ErrorCode_xWMACreateDecoderFailed: root::AK::Monitor::ErrorCode =
                15;
            pub const ErrorCode_ErrorCode_ATRAC9DecodeFailed: root::AK::Monitor::ErrorCode = 16;
            pub const ErrorCode_ErrorCode_ATRAC9LoopSectionTooSmall: root::AK::Monitor::ErrorCode =
                17;
            pub const ErrorCode_ErrorCode_InvalidAudioFileHeader: root::AK::Monitor::ErrorCode = 18;
            pub const ErrorCode_ErrorCode_AudioFileHeaderTooLarge: root::AK::Monitor::ErrorCode =
                19;
            pub const ErrorCode_ErrorCode_FileTooSmall: root::AK::Monitor::ErrorCode = 20;
            pub const ErrorCode_ErrorCode_TransitionNotAccurateChannel:
                root::AK::Monitor::ErrorCode = 21;
            pub const ErrorCode_ErrorCode_TransitionNotAccuratePluginMismatch:
                root::AK::Monitor::ErrorCode = 22;
            pub const ErrorCode_ErrorCode_TransitionNotAccurateRejectedByPlugin:
                root::AK::Monitor::ErrorCode = 23;
            pub const ErrorCode_ErrorCode_TransitionNotAccurateStarvation:
                root::AK::Monitor::ErrorCode = 24;
            pub const ErrorCode_ErrorCode_TransitionNotAccurateCodecError:
                root::AK::Monitor::ErrorCode = 25;
            pub const ErrorCode_ErrorCode_NothingToPlay: root::AK::Monitor::ErrorCode = 26;
            pub const ErrorCode_ErrorCode_PlayFailed: root::AK::Monitor::ErrorCode = 27;
            pub const ErrorCode_ErrorCode_StingerCouldNotBeScheduled: root::AK::Monitor::ErrorCode =
                28;
            pub const ErrorCode_ErrorCode_TooLongSegmentLookAhead: root::AK::Monitor::ErrorCode =
                29;
            pub const ErrorCode_ErrorCode_CannotScheduleMusicSwitch: root::AK::Monitor::ErrorCode =
                30;
            pub const ErrorCode_ErrorCode_TooManySimultaneousMusicSegments:
                root::AK::Monitor::ErrorCode = 31;
            pub const ErrorCode_ErrorCode_PlaylistStoppedForEditing: root::AK::Monitor::ErrorCode =
                32;
            pub const ErrorCode_ErrorCode_MusicClipsRescheduledAfterTrackEdit:
                root::AK::Monitor::ErrorCode = 33;
            pub const ErrorCode_ErrorCode_CannotPlaySource_Create: root::AK::Monitor::ErrorCode =
                34;
            pub const ErrorCode_ErrorCode_CannotPlaySource_VirtualOff:
                root::AK::Monitor::ErrorCode = 35;
            pub const ErrorCode_ErrorCode_CannotPlaySource_TimeSkip: root::AK::Monitor::ErrorCode =
                36;
            pub const ErrorCode_ErrorCode_CannotPlaySource_InconsistentState:
                root::AK::Monitor::ErrorCode = 37;
            pub const ErrorCode_ErrorCode_MediaNotLoaded: root::AK::Monitor::ErrorCode = 38;
            pub const ErrorCode_ErrorCode_VoiceStarving: root::AK::Monitor::ErrorCode = 39;
            pub const ErrorCode_ErrorCode_StreamingSourceStarving: root::AK::Monitor::ErrorCode =
                40;
            pub const ErrorCode_ErrorCode_XMADecoderSourceStarving: root::AK::Monitor::ErrorCode =
                41;
            pub const ErrorCode_ErrorCode_XMADecodingError: root::AK::Monitor::ErrorCode = 42;
            pub const ErrorCode_ErrorCode_InvalidXMAData: root::AK::Monitor::ErrorCode = 43;
            pub const ErrorCode_ErrorCode_PluginNotRegistered: root::AK::Monitor::ErrorCode = 44;
            pub const ErrorCode_ErrorCode_CodecNotRegistered: root::AK::Monitor::ErrorCode = 45;
            pub const ErrorCode_ErrorCode_PluginVersionMismatch: root::AK::Monitor::ErrorCode = 46;
            pub const ErrorCode_ErrorCode_EventIDNotFound: root::AK::Monitor::ErrorCode = 47;
            pub const ErrorCode_ErrorCode_InvalidGroupID: root::AK::Monitor::ErrorCode = 48;
            pub const ErrorCode_ErrorCode_SelectedChildNotAvailable: root::AK::Monitor::ErrorCode =
                49;
            pub const ErrorCode_ErrorCode_SelectedNodeNotAvailable: root::AK::Monitor::ErrorCode =
                50;
            pub const ErrorCode_ErrorCode_SelectedMediaNotAvailable: root::AK::Monitor::ErrorCode =
                51;
            pub const ErrorCode_ErrorCode_NoValidSwitch: root::AK::Monitor::ErrorCode = 52;
            pub const ErrorCode_ErrorCode_SelectedNodeNotAvailablePlay:
                root::AK::Monitor::ErrorCode = 53;
            pub const ErrorCode_ErrorCode_FeedbackVoiceStarving: root::AK::Monitor::ErrorCode = 54;
            pub const ErrorCode_ErrorCode_BankLoadFailed: root::AK::Monitor::ErrorCode = 55;
            pub const ErrorCode_ErrorCode_BankUnloadFailed: root::AK::Monitor::ErrorCode = 56;
            pub const ErrorCode_ErrorCode_ErrorWhileLoadingBank: root::AK::Monitor::ErrorCode = 57;
            pub const ErrorCode_ErrorCode_InsufficientSpaceToLoadBank:
                root::AK::Monitor::ErrorCode = 58;
            pub const ErrorCode_ErrorCode_LowerEngineCommandListFull: root::AK::Monitor::ErrorCode =
                59;
            pub const ErrorCode_ErrorCode_SeekNoMarker: root::AK::Monitor::ErrorCode = 60;
            pub const ErrorCode_ErrorCode_CannotSeekContinuous: root::AK::Monitor::ErrorCode = 61;
            pub const ErrorCode_ErrorCode_SeekAfterEof: root::AK::Monitor::ErrorCode = 62;
            pub const ErrorCode_ErrorCode_UnknownGameObject: root::AK::Monitor::ErrorCode = 63;
            pub const ErrorCode_ErrorCode_UnknownEmitter: root::AK::Monitor::ErrorCode = 64;
            pub const ErrorCode_ErrorCode_UnknownListener: root::AK::Monitor::ErrorCode = 65;
            pub const ErrorCode_ErrorCode_GameObjectIsNotListener: root::AK::Monitor::ErrorCode =
                66;
            pub const ErrorCode_ErrorCode_GameObjectIsNotEmitter: root::AK::Monitor::ErrorCode = 67;
            pub const ErrorCode_ErrorCode_UnknownGameObjectEvent: root::AK::Monitor::ErrorCode = 68;
            pub const ErrorCode_ErrorCode_GameObjectIsNotEmitterEvent:
                root::AK::Monitor::ErrorCode = 69;
            pub const ErrorCode_ErrorCode_ExternalSourceNotResolved: root::AK::Monitor::ErrorCode =
                70;
            pub const ErrorCode_ErrorCode_FileFormatMismatch: root::AK::Monitor::ErrorCode = 71;
            pub const ErrorCode_ErrorCode_CommandQueueFull: root::AK::Monitor::ErrorCode = 72;
            pub const ErrorCode_ErrorCode_CommandTooLarge: root::AK::Monitor::ErrorCode = 73;
            pub const ErrorCode_ErrorCode_XMACreateDecoderLimitReached:
                root::AK::Monitor::ErrorCode = 74;
            pub const ErrorCode_ErrorCode_XMAStreamBufferTooSmall: root::AK::Monitor::ErrorCode =
                75;
            pub const ErrorCode_ErrorCode_ModulatorScopeError_Inst: root::AK::Monitor::ErrorCode =
                76;
            pub const ErrorCode_ErrorCode_ModulatorScopeError_Obj: root::AK::Monitor::ErrorCode =
                77;
            pub const ErrorCode_ErrorCode_SeekAfterEndOfPlaylist: root::AK::Monitor::ErrorCode = 78;
            pub const ErrorCode_ErrorCode_OpusRequireSeekTable: root::AK::Monitor::ErrorCode = 79;
            pub const ErrorCode_ErrorCode_OpusDecodeError: root::AK::Monitor::ErrorCode = 80;
            pub const ErrorCode_ErrorCode_OpusCreateDecoderFailed: root::AK::Monitor::ErrorCode =
                81;
            pub const ErrorCode_ErrorCode_SourcePluginNotFound: root::AK::Monitor::ErrorCode = 82;
            pub const ErrorCode_ErrorCode_VirtualVoiceLimit: root::AK::Monitor::ErrorCode = 83;
            pub const ErrorCode_ErrorCode_AudioDeviceShareSetNotFound:
                root::AK::Monitor::ErrorCode = 84;
            pub const ErrorCode_ErrorCode_NotEnoughMemoryToStart: root::AK::Monitor::ErrorCode = 85;
            pub const ErrorCode_ErrorCode_UnkownOpusError: root::AK::Monitor::ErrorCode = 86;
            pub const ErrorCode_ErrorCode_AudioDeviceInitFailure: root::AK::Monitor::ErrorCode = 87;
            pub const ErrorCode_ErrorCode_AudioDeviceRemoveFailure: root::AK::Monitor::ErrorCode =
                88;
            pub const ErrorCode_ErrorCode_AudioDeviceNotFound: root::AK::Monitor::ErrorCode = 89;
            pub const ErrorCode_ErrorCode_AudioDeviceNotValid: root::AK::Monitor::ErrorCode = 90;
            pub const ErrorCode_ErrorCode_SpatialAudio_ListenerAutomationNotSupported:
                root::AK::Monitor::ErrorCode = 91;
            pub const ErrorCode_ErrorCode_MediaDuplicationLength: root::AK::Monitor::ErrorCode = 92;
            pub const ErrorCode_ErrorCode_HwVoicesSystemInitFailed: root::AK::Monitor::ErrorCode =
                93;
            pub const ErrorCode_ErrorCode_HwVoicesDecodeBatchFailed: root::AK::Monitor::ErrorCode =
                94;
            pub const ErrorCode_ErrorCode_HwVoiceLimitReached: root::AK::Monitor::ErrorCode = 95;
            pub const ErrorCode_ErrorCode_HwVoiceInitFailed: root::AK::Monitor::ErrorCode = 96;
            pub const ErrorCode_ErrorCode_OpusHWCommandFailed: root::AK::Monitor::ErrorCode = 97;
            pub const ErrorCode_ErrorCode_AddOutputListenerIdWithZeroListeners:
                root::AK::Monitor::ErrorCode = 98;
            pub const ErrorCode_ErrorCode_3DObjectLimitExceeded: root::AK::Monitor::ErrorCode = 99;
            pub const ErrorCode_ErrorCode_OpusHWDecodeUnavailable: root::AK::Monitor::ErrorCode =
                100;
            pub const ErrorCode_ErrorCode_OpusHWFatalError: root::AK::Monitor::ErrorCode = 101;
            pub const ErrorCode_ErrorCode_OpusHWTimeout: root::AK::Monitor::ErrorCode = 102;
            pub const ErrorCode_ErrorCode_SystemAudioObjectsUnavailable:
                root::AK::Monitor::ErrorCode = 103;
            pub const ErrorCode_ErrorCode_AddOutputNoDistinctListener:
                root::AK::Monitor::ErrorCode = 104;
            pub const ErrorCode_ErrorCode_PluginCannotRunOnObjectConfig:
                root::AK::Monitor::ErrorCode = 105;
            pub const ErrorCode_ErrorCode_SpatialAudio_ReflectionBusError:
                root::AK::Monitor::ErrorCode = 106;
            pub const ErrorCode_ErrorCode_VorbisHWDecodeUnavailable: root::AK::Monitor::ErrorCode =
                107;
            pub const ErrorCode_Num_ErrorCodes: root::AK::Monitor::ErrorCode = 108;
            #[doc = " ErrorCode"]
            pub type ErrorCode = ::std::os::raw::c_uint;
            pub type LocalOutputFunc = ::std::option::Option<
                unsafe extern "C" fn(
                    in_eErrorCode: root::AK::Monitor::ErrorCode,
                    in_pszError: *const root::AkOSChar,
                    in_eErrorLevel: root::AK::Monitor::ErrorLevel,
                    in_playingID: root::AkPlayingID,
                    in_gameObjID: root::AkGameObjectID,
                ),
            >;
            extern "C" {
                #[link_name = "\u{1}__ZN2AK7Monitor15s_aszErrorCodesE"]
                pub static mut s_aszErrorCodes: [*const root::AkOSChar; 108usize];
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK7Monitor8PostCodeENS0_9ErrorCodeENS0_10ErrorLevelEjyjb"]
                pub fn PostCode(
                    in_eError: root::AK::Monitor::ErrorCode,
                    in_eErrorLevel: root::AK::Monitor::ErrorLevel,
                    in_playingID: root::AkPlayingID,
                    in_gameObjID: root::AkGameObjectID,
                    in_audioNodeID: root::AkUniqueID,
                    in_bIsBus: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK7Monitor10PostStringEPKwNS0_10ErrorLevelEjyjb"]
                pub fn PostString(
                    in_pszError: *const u32,
                    in_eErrorLevel: root::AK::Monitor::ErrorLevel,
                    in_playingID: root::AkPlayingID,
                    in_gameObjID: root::AkGameObjectID,
                    in_audioNodeID: root::AkUniqueID,
                    in_bIsBus: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK7Monitor10PostStringEPKcNS0_10ErrorLevelEjyjb"]
                pub fn PostString1(
                    in_pszError: *const ::std::os::raw::c_char,
                    in_eErrorLevel: root::AK::Monitor::ErrorLevel,
                    in_playingID: root::AkPlayingID,
                    in_gameObjID: root::AkGameObjectID,
                    in_audioNodeID: root::AkUniqueID,
                    in_bIsBus: bool,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK7Monitor14SetLocalOutputEjPFvNS0_9ErrorCodeEPKcNS0_10ErrorLevelEjyE"]
                pub fn SetLocalOutput(
                    in_uErrorLevel: root::AkUInt32,
                    in_pMonitorFunc: root::AK::Monitor::LocalOutputFunc,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK7Monitor12GetTimeStampEv"]
                pub fn GetTimeStamp() -> root::AkTimeMs;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK7Monitor20MonitorStreamMgrInitERK19AkStreamMgrSettings"]
                pub fn MonitorStreamMgrInit(in_streamMgrSettings: *const root::AkStreamMgrSettings);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK7Monitor26MonitorStreamingDeviceInitEjRK16AkDeviceSettings"]
                pub fn MonitorStreamingDeviceInit(
                    in_deviceID: root::AkDeviceID,
                    in_deviceSettings: *const root::AkDeviceSettings,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK7Monitor31MonitorStreamingDeviceDestroyedEj"]
                pub fn MonitorStreamingDeviceDestroyed(in_deviceID: root::AkDeviceID);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK7Monitor20MonitorStreamMgrTermEv"]
                pub fn MonitorStreamMgrTerm();
            }
        }
        #[doc = "SSE support."]
        pub const AkSIMDProcessorSupport_AK_SIMD_SSE: root::AK::AkSIMDProcessorSupport = 1;
        #[doc = "SSE2 support."]
        pub const AkSIMDProcessorSupport_AK_SIMD_SSE2: root::AK::AkSIMDProcessorSupport = 2;
        #[doc = "SSE3 support."]
        pub const AkSIMDProcessorSupport_AK_SIMD_SSE3: root::AK::AkSIMDProcessorSupport = 4;
        #[doc = "SSSE3 support."]
        pub const AkSIMDProcessorSupport_AK_SIMD_SSSE3: root::AK::AkSIMDProcessorSupport = 8;
        #[doc = "SSE 4.1 support."]
        pub const AkSIMDProcessorSupport_AK_SIMD_SSE41: root::AK::AkSIMDProcessorSupport = 16;
        #[doc = "AVX support."]
        pub const AkSIMDProcessorSupport_AK_SIMD_AVX: root::AK::AkSIMDProcessorSupport = 32;
        #[doc = "F16C support."]
        pub const AkSIMDProcessorSupport_AK_SIMD_F16C: root::AK::AkSIMDProcessorSupport = 64;
        #[doc = "AVX2 support."]
        pub const AkSIMDProcessorSupport_AK_SIMD_AVX2: root::AK::AkSIMDProcessorSupport = 128;
        #[doc = " SIMD instruction sets."]
        pub type AkSIMDProcessorSupport = ::std::os::raw::c_uint;
        #[repr(C)]
        pub struct IAkProcessorFeatures__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Runtime processor supported features detection interface. Allows to query specific processor features"]
        #[doc = " to chose optimal implementation."]
        #[doc = " \\akwarning"]
        #[doc = " The functions in this interface are not thread-safe, unless stated otherwise."]
        #[doc = " \\endakwarning"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkProcessorFeatures {
            pub vtable_: *const IAkProcessorFeatures__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IAkPlatformContext__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Base interface for platform-specific context."]
        #[doc = " You must static_cast this object to a platform-specific derivative to get anything useful out of it."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkPlatformContext {
            pub vtable_: *const IAkPlatformContext__bindgen_vtable,
        }
        #[doc = "Sent after an Audio Device has initialized.  Initialization might have failed, check the AKRESULT."]
        pub const AkAudioDeviceEvent_AkAudioDeviceEvent_Initialization:
            root::AK::AkAudioDeviceEvent = 0;
        #[doc = "Audio device was removed through explicit call (AK::SoundEngine::RemoveOutput or AK::SoundEngine::Term)"]
        pub const AkAudioDeviceEvent_AkAudioDeviceEvent_Removal: root::AK::AkAudioDeviceEvent = 1;
        #[doc = "Audio device was removed because of a system event (disconnection), hardware or driver problem. Check the AKRESULT when called through AkDeviceStatusCallbackFunc, it may give more context."]
        pub const AkAudioDeviceEvent_AkAudioDeviceEvent_SystemRemoval:
            root::AK::AkAudioDeviceEvent = 2;
        pub type AkAudioDeviceEvent = ::std::os::raw::c_uint;
        pub type AkDeviceStatusCallbackFunc = ::std::option::Option<
            unsafe extern "C" fn(
                in_pContext: *mut root::AK::IAkGlobalPluginContext,
                in_idAudioDeviceShareset: root::AkUniqueID,
                in_idDeviceID: root::AkUInt32,
                in_idEvent: root::AK::AkAudioDeviceEvent,
                in_AkResult: root::AKRESULT,
            ),
        >;
        #[repr(C)]
        pub struct IAkGameObjectPluginInfo__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Game object information available to plugins."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkGameObjectPluginInfo {
            pub vtable_: *const IAkGameObjectPluginInfo__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IAkVoicePluginInfo__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Voice-specific information available to plug-ins."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkVoicePluginInfo {
            pub vtable_: *const IAkVoicePluginInfo__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IAkPluginContextBase__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Interface to retrieve contextual information available to all types of plugins."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkPluginContextBase {
            pub vtable_: *const IAkPluginContextBase__bindgen_vtable,
        }
        #[doc = " Interface to retrieve contextual information for an effect plug-in."]
        #[doc = " \\sa"]
        #[doc = " - \\ref iakmonadiceffect_init"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkEffectPluginContext {
            pub _base: root::AK::IAkPluginContextBase,
        }
        #[doc = " Interface to retrieve contextual information for a source plug-in."]
        #[doc = " \\sa"]
        #[doc = " - \\ref iaksourceeffect_init"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkSourcePluginContext {
            pub _base: root::AK::IAkPluginContextBase,
        }
        #[doc = " Interface to retrieve contextual information for a mixer."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkMixerPluginContext {
            pub _base: root::AK::IAkPluginContextBase,
        }
        #[doc = " Parameter node interface, managing access to an enclosed parameter structure."]
        #[doc = " \\aknote The implementer of this interface should also expose a static creation function"]
        #[doc = " that will return a new parameter node instance when required (see \\ref se_plugins_overview). \\endaknote"]
        #[doc = " \\sa"]
        #[doc = " - \\ref shared_parameter_interface"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkPluginParam {
            pub _base: root::AK::IAkRTPCSubscriber,
        }
        #[doc = " Use this constant with AK::Wwise::IPluginPropertySet::NotifyInternalDataChanged,"]
        #[doc = " AK::Wwise::IAudioPlugin::GetPluginData and IAkPluginParam::SetParam. This tells"]
        #[doc = " that the whole plugin data needs to be saved/transferred."]
        #[doc = "\\sa"]
        #[doc = " - AK::Wwise::IPluginPropertySet::NotifyInternalDataChanged"]
        #[doc = " - AK::Wwise::IAudioPlugin::GetPluginData"]
        #[doc = " - AK::IAkPluginParam::SetParam"]
        pub const IAkPluginParam_ALL_PLUGIN_DATA_ID: root::AkPluginParamID = 32767;
        #[repr(C)]
        pub struct IAkPlugin__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Wwise sound engine plug-in interface. Shared functionality across different plug-in types."]
        #[doc = " \\aknote The implementer of this interface should also expose a static creation function"]
        #[doc = " that will return a new plug-in instance when required (see \\ref soundengine_plugins). \\endaknote"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkPlugin {
            pub vtable_: *const IAkPlugin__bindgen_vtable,
        }
        #[doc = " Software effect plug-in interface (see \\ref soundengine_plugins_effects)."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkEffectPlugin {
            pub _base: root::AK::IAkPlugin,
        }
        #[doc = " Software effect plug-in interface for in-place processing (see \\ref soundengine_plugins_effects)."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkInPlaceEffectPlugin {
            pub _base: root::AK::IAkEffectPlugin,
        }
        #[doc = " Software effect plug-in interface for out-of-place processing (see \\ref soundengine_plugins_effects)."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkOutOfPlaceEffectPlugin {
            pub _base: root::AK::IAkEffectPlugin,
        }
        #[doc = " In-place Object Processor plug-in interface. Implement this interface when your plugin returns both AkPluginInfo::bCanProcessObjects"]
        #[doc = " and AkPluginInfo::bIsInPlace set to true."]
        #[doc = " In-place object processors just modify objects' audio or metadata, but do not destroy objects create additional output objects."]
        #[doc = " An object processor may be initialized with an Object configuration, or any channel configuration, depending on the configuration of its input."]
        #[doc = " It is not allowed to change the channel configuration in Init."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkInPlaceObjectPlugin {
            pub _base: root::AK::IAkEffectPlugin,
        }
        #[doc = " Out-of-place Object Processor plug-in interface. Implement this interface when your plugin returns AkPluginInfo::bCanProcessObjects set to true"]
        #[doc = " and AkPluginInfo::bIsInPlace set to false."]
        #[doc = " With out-of-place object processors, the set of output objects is different than that of the input objects. Out-of-place object processors typically create"]
        #[doc = " their own output objects using IAkEffectPluginContext::CreateObject. Alternatively, an output object is created by the host bus if the channel configuration"]
        #[doc = " returned from Init is not of type AK_ChannelConfigType_Objects."]
        #[doc = " Only out-of-place object processors may create output objects or change the output channel configuration."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkOutOfPlaceObjectPlugin {
            pub _base: root::AK::IAkEffectPlugin,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkAudioDeviceEffectPluginContext {
            pub _base: root::AK::IAkPluginContextBase,
        }
        #[doc = " Audio device effect plug-in interface. Implement this interface for in-place effects that must be applied at the very end of the pipeline."]
        #[doc = " Audio device effects are applied right before sending audio buffers (main mix, passthrough and objects) to the audio device output through IAkSinkPlugin/IAk3DAudioSinkPlugin."]
        #[doc = " The format of the audio buffers passed to the effect matches the format requested by the sink plug-in. This means that audio device effects must be in-place; they cannot change io_rFormat in Init()."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkAudioDeviceEffectPlugin {
            pub _base: root::AK::IAkPlugin,
        }
        #[repr(C)]
        pub struct IAkMixerInputContext__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Interface to retrieve information about an input of a mixer."]
        #[doc = " DEPRECATED."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkMixerInputContext {
            pub vtable_: *const IAkMixerInputContext__bindgen_vtable,
        }
        #[doc = " Interface to retrieve contextual information for a sink plugin."]
        #[doc = " \\sa"]
        #[doc = " - AK::IAkSinkPlugin"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkSinkPluginContext {
            pub _base: root::AK::IAkPluginContextBase,
        }
        pub const AkSinkPluginType_AkSinkPluginType_Sink: root::AK::AkSinkPluginType = 0;
        pub const AkSinkPluginType_AkSinkPluginType_3DAudioSink: root::AK::AkSinkPluginType = 1;
        pub type AkSinkPluginType = ::std::os::raw::c_uint;
        #[doc = " Software interface for sink (audio endpoint) plugins."]
        #[doc = " This interface should not be implemented directly,"]
        #[doc = " Plug-ins should either implement:"]
        #[doc = "   - IAkSinkPlugin: for audio endpoint that do not support 3D audio, or"]
        #[doc = "   - IAk3DAudioSinkPlugin: for audio endpoints that support 3D audio features."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkSinkPluginBase {
            pub _base: root::AK::IAkPlugin,
        }
        #[doc = " Software interface for sink (audio endpoint) plugins."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkSinkPlugin {
            pub _base: root::AK::IAkSinkPluginBase,
        }
        #[doc = " Software plug-in interface for sink (audio end point) which supports 3D audio features."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAk3DAudioSinkPlugin {
            pub _base: root::AK::IAkSinkPluginBase,
        }
        #[doc = " Wwise sound engine source plug-in interface (see \\ref soundengine_plugins_source)."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkSourcePlugin {
            pub _base: root::AK::IAkPlugin,
        }
        pub const AkPluginServiceType_PluginServiceType_Mixer: root::AK::AkPluginServiceType = 0;
        pub const AkPluginServiceType_PluginServiceType_MAX: root::AK::AkPluginServiceType = 1;
        pub type AkPluginServiceType = ::std::os::raw::c_uint;
        #[repr(C)]
        pub struct IAkPluginService__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Common interface for plug-in services accessed through the global plug-in context"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkPluginService {
            pub vtable_: *const IAkPluginService__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IAkGlobalPluginContext__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Global plug-in context used for plug-in registration/initialization."]
        #[doc = " Games query this interface from the sound engine, via AK::SoundEngine::GetGlobalPluginContext. Plug-ins query it via IAkPluginContextBase::GlobalContext."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkGlobalPluginContext {
            pub vtable_: *const IAkGlobalPluginContext__bindgen_vtable,
        }
        #[doc = " Interface for the \"Mixer\" plug-in service, to handle mixing together of signals, or applying simple transforms"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkPluginServiceMixer {
            pub _base: root::AK::IAkPluginService,
        }
        #[doc = " This class takes care of the registration of plug-ins in the Wwise engine.  Plug-in developers must provide one instance of this class for each plug-in."]
        #[doc = " \\sa"]
        #[doc = " - \\ref soundengine_plugins"]
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PluginRegistration {
            pub pNext: *mut root::AK::PluginRegistration,
            pub m_eType: root::AkPluginType,
            pub m_ulCompanyID: root::AkUInt32,
            pub m_ulPluginID: root::AkUInt32,
            pub m_pCreateFunc: root::AkCreatePluginCallback,
            pub m_pCreateParamFunc: root::AkCreateParamCallback,
            #[doc = "LEGACY: Kept for compatibility with 2019.1. Unused in 2019.2 and up."]
            pub m_pFileCreateFunc: root::AkCreateFileSourceCallback,
            #[doc = "LEGACY: Kept for compatibility with 2019.1. Unused in 2019.2 and up."]
            pub m_pBankCreateFunc: root::AkCreateBankSourceCallback,
            pub m_pRegisterCallback: root::AkGlobalCallbackFunc,
            pub m_pRegisterCallbackCookie: *mut ::std::os::raw::c_void,
            pub m_pGetDeviceListFunc: root::AkGetDeviceListCallback,
            pub m_CodecDescriptor: root::AkCodecDescriptor,
        }
        #[doc = " Context specific to the macOS port of Wwise SDK."]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkMacContext {
            pub _base: root::AK::IAkPlatformContext,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IReadBytes {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IWriteBytes {
            _unused: [u8; 0],
        }
        #[repr(C)]
        pub struct IAkStreamProfile__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Profiling interface of streams."]
        #[doc = " \\akwarning"]
        #[doc = " The functions in this interface are not thread-safe, unless stated otherwise."]
        #[doc = " \\endakwarning"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkStreamProfile {
            pub vtable_: *const IAkStreamProfile__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IAkDeviceProfile__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Profiling interface of high-level I/O devices."]
        #[doc = " \\akwarning"]
        #[doc = " The functions in this interface are not thread-safe, unless stated otherwise."]
        #[doc = " \\endakwarning"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkDeviceProfile {
            pub vtable_: *const IAkDeviceProfile__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IAkStreamMgrProfile__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Profiling interface of the Stream Manager."]
        #[doc = " \\akwarning"]
        #[doc = " The functions in this interface are not thread-safe, unless stated otherwise."]
        #[doc = " \\endakwarning"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkStreamMgrProfile {
            pub vtable_: *const IAkStreamMgrProfile__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IAkStdStream__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Interface of standard streams. Used as a handle to a standard stream. Has methods for"]
        #[doc = " stream control. Obtained through the Stream Manager's AK::IAkStreamMgr::CreateStd() method."]
        #[doc = " \\akwarning"]
        #[doc = " The functions in this interface are not thread-safe, unless stated otherwise."]
        #[doc = " \\endakwarning"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkStdStream {
            pub vtable_: *const IAkStdStream__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IAkAutoStream__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Interface of automatic streams. It is used as a handle to a stream,"]
        #[doc = " I/O operations are triggered from here."]
        #[doc = " Obtained through the Stream Manager's AK::IAkStreamMgr::CreateAuto() method."]
        #[doc = " \\akwarning"]
        #[doc = " The functions in this interface are not thread-safe, unless stated otherwise."]
        #[doc = " \\endakwarning"]
        #[doc = " \\sa"]
        #[doc = " - \\ref streamingdevicemanager"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkAutoStream {
            pub vtable_: *const IAkAutoStream__bindgen_vtable,
        }
        #[repr(C)]
        pub struct IAkStreamMgr__bindgen_vtable(::std::os::raw::c_void);
        #[doc = " Interface of the Stream Manager."]
        #[doc = " \\akwarning"]
        #[doc = " The functions in this interface are not thread-safe, unless stated otherwise."]
        #[doc = " \\endakwarning"]
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAkStreamMgr {
            pub vtable_: *const IAkStreamMgr__bindgen_vtable,
        }
        extern "C" {
            #[doc = " Definition of the global pointer to the interface of the Stream Manager singleton."]
            #[doc = " \\sa"]
            #[doc = " - \\ref streamingdevicemanager"]
            #[link_name = "\u{1}__ZN2AK12IAkStreamMgr12m_pStreamMgrE"]
            pub static mut IAkStreamMgr_m_pStreamMgr: *mut root::AK::IAkStreamMgr;
        }
        pub mod StreamMgr {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct IAkLowLevelIOHook__bindgen_vtable(::std::os::raw::c_void);
            #[doc = " Base interface for Low-Level I/O hooks. Defines common methods across both types of hooks."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IAkLowLevelIOHook {
                pub vtable_: *const IAkLowLevelIOHook__bindgen_vtable,
            }
            #[doc = " Interface for blocking low-level I/O transfers. Used by streaming devices created with the"]
            #[doc = " AK_SCHEDULER_BLOCKING flag."]
            #[doc = " This is the simplest I/O hook. Calls to Read()/Write() must block until they are completed."]
            #[doc = " The streaming device's I/O thread sends one transfer at a time."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IAkIOHookBlocking {
                pub _base: root::AK::StreamMgr::IAkLowLevelIOHook,
            }
            #[doc = " Interface for batched deferred low-level I/O transfers. Used by streaming devices created"]
            #[doc = " with the AK_SCHEDULER_DEFERRED_LINED_UP flag."]
            #[doc = " This I/O transfer handshaking method is preferred when you want to hook I/O to your own"]
            #[doc = " I/O streaming technology, and you want to submit multiple I/O requests in one call, so as"]
            #[doc = " to allow for better opportunities for CPU and I/O performance."]
            #[doc = " You may queue them into your own system, and even use the heuristics passed down to this"]
            #[doc = " level for your convenience. Note that the requests are always sent in the order that the"]
            #[doc = " Stream Manager considers to be the most appropriate. You may receive less than"]
            #[doc = " AkDeviceSettings::uMaxConcurrentIO at any given time. The number of concurrent transfers"]
            #[doc = " depends on the number of streams running in the high-level streaming device, and on its"]
            #[doc = " target buffering length and granularity. Your advantage at this level is to be aware of"]
            #[doc = " file placement, so you may try to re-order requests in order to minimize seeking on disk."]
            #[doc = " Calls to BatchRead()/BatchWrite() should return as soon as possible. You need to call"]
            #[doc = " AkAsyncIOTransferInfo::pCallback for an individual item, or AkBatchIOCallback for a collection"]
            #[doc = " of items as soon as a transfer is completed."]
            #[doc = " Cancel() is provided in order to inform you that the streaming device will flush this transfer"]
            #[doc = " upon completion. You may implement it or not. In all cases, you must call the callback."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IAkIOHookDeferredBatch {
                pub _base: root::AK::StreamMgr::IAkLowLevelIOHook,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct IAkIOHookDeferredBatch_BatchIoTransferItem {
                pub pFileDesc: *mut root::AkFileDesc,
                pub ioHeuristics: root::AkIoHeuristics,
                pub pTransferInfo: *mut root::AkAsyncIOTransferInfo,
            }
            #[doc = " Interface for deferred low-level I/O transfers. Used by streaming devices created with the"]
            #[doc = " AK_SCHEDULER_DEFERRED_LINED_UP flag."]
            #[doc = " This is an \"adapter\" interface to forward calls to IAkIOHookDeferredBatch, to maintain"]
            #[doc = " compatibility with existing implementations, as well as provide a simpler interface for new"]
            #[doc = " implementations."]
            #[doc = " This I/O transfer handshaking method is preferred when you want to hook I/O to your own"]
            #[doc = " I/O streaming technology. You will receive up to AkDeviceSettings::uMaxConcurrentIO requests"]
            #[doc = " at the same time. You may queue them into your own system, and even use the heuristics passed"]
            #[doc = " down to this level for your convenience."]
            #[doc = " Note that the requests are always sent in the order that the Stream Manager considers to be"]
            #[doc = " the most appropriate. You may receive less than AkDeviceSettings::uMaxConcurrentIO at any"]
            #[doc = " given time. The number of concurrent transfers depends on the number of streams running in"]
            #[doc = " the high-level streaming device, and on its target buffering length and granularity."]
            #[doc = " Your advantage at this level is to be aware of file placement, so you may try to re-order"]
            #[doc = " requests in order to minimize seeking on disk."]
            #[doc = " Calls to Read()/Write() should return as soon as possible. You need to call"]
            #[doc = " AkAsyncIOTransferInfo::pCallback as soon as a transfer is completed."]
            #[doc = " Cancel() is provided in order to inform you that the streaming device will flush this transfer"]
            #[doc = " upon completion. You may implement it or not. In all cases, you must call the callback."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IAkIOHookDeferred {
                pub _base: root::AK::StreamMgr::IAkIOHookDeferredBatch,
            }
            #[repr(C)]
            pub struct IAkFileLocationResolver__bindgen_vtable(::std::os::raw::c_void);
            #[doc = " File location resolver interface. There is one and only one File Location Resolver that is"]
            #[doc = " registered to the Stream Manager (using AK::StreamMgr::SetFileLocationResolver()). Its purpose"]
            #[doc = " is to map a file name or ID to"]
            #[doc = " 1) a streaming device / I/O hook;"]
            #[doc = " 2) a valid file descriptor (AkFileDesc) usable by the I/O hook."]
            #[doc = " When your Low-Level I/O submodule uses a single device, you should create a standalone I/O"]
            #[doc = " hook which implements one of the I/O hooks defined above (blocking or deferred), as well"]
            #[doc = " as the File Location Resolver. You then register this object to the Stream Manager as the"]
            #[doc = " File Location Resolver."]
            #[doc = " If you wish to create multiple devices, then you should have a separate object that implements"]
            #[doc = " AK::StreamMgr::IAkFileLocationResolver and registers to the Stream Manager as such. This object"]
            #[doc = " will be used to dispatch the file open request to the appropriate device. The strategy you will"]
            #[doc = " use to select the correct device is up to you to implement. You may also implement a set of"]
            #[doc = " hooks that delegate opening to the next device when they can't find the file requested"]
            #[doc = " (like a chain of responsiblity pattern), although this will likely be less efficient."]
            #[repr(C)]
            #[derive(Debug)]
            pub struct IAkFileLocationResolver {
                pub vtable_: *const IAkFileLocationResolver__bindgen_vtable,
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9StreamMgr6CreateERK19AkStreamMgrSettings"]
                pub fn Create(
                    in_settings: *const root::AkStreamMgrSettings,
                ) -> *mut root::AK::IAkStreamMgr;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9StreamMgr18GetDefaultSettingsER19AkStreamMgrSettings"]
                pub fn GetDefaultSettings(out_settings: *mut root::AkStreamMgrSettings);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9StreamMgr23GetFileLocationResolverEv"]
                pub fn GetFileLocationResolver() -> *mut root::AK::StreamMgr::IAkFileLocationResolver;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9StreamMgr23SetFileLocationResolverEPNS0_23IAkFileLocationResolverE"]
                pub fn SetFileLocationResolver(
                    in_pFileLocationResolver: *mut root::AK::StreamMgr::IAkFileLocationResolver,
                );
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9StreamMgr12CreateDeviceERK16AkDeviceSettingsPNS0_17IAkLowLevelIOHookE"]
                pub fn CreateDevice(
                    in_settings: *const root::AkDeviceSettings,
                    in_pLowLevelHook: *mut root::AK::StreamMgr::IAkLowLevelIOHook,
                ) -> root::AkDeviceID;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9StreamMgr13DestroyDeviceEj"]
                pub fn DestroyDevice(in_deviceID: root::AkDeviceID) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9StreamMgr24GetDefaultDeviceSettingsER16AkDeviceSettings"]
                pub fn GetDefaultDeviceSettings(out_settings: *mut root::AkDeviceSettings);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9StreamMgr18SetCurrentLanguageEPKc"]
                pub fn SetCurrentLanguage(
                    in_pszLanguageName: *const root::AkOSChar,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9StreamMgr18GetCurrentLanguageEv"]
                pub fn GetCurrentLanguage() -> *const root::AkOSChar;
            }
            pub type AkLanguageChangeHandler = ::std::option::Option<
                unsafe extern "C" fn(
                    in_pLanguageName: *const root::AkOSChar,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ),
            >;
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9StreamMgr25AddLanguageChangeObserverEPFvPKcPvES3_"]
                pub fn AddLanguageChangeObserver(
                    in_handler: root::AK::StreamMgr::AkLanguageChangeHandler,
                    in_pCookie: *mut ::std::os::raw::c_void,
                ) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9StreamMgr28RemoveLanguageChangeObserverEPv"]
                pub fn RemoveLanguageChangeObserver(in_pCookie: *mut ::std::os::raw::c_void);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK9StreamMgr14FlushAllCachesEv"]
                pub fn FlushAllCaches();
            }
        }
        pub mod MusicEngine {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11MusicEngine4InitEP15AkMusicSettings"]
                pub fn Init(in_pSettings: *mut root::AkMusicSettings) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11MusicEngine22GetDefaultInitSettingsER15AkMusicSettings"]
                pub fn GetDefaultInitSettings(out_settings: *mut root::AkMusicSettings);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11MusicEngine4TermEv"]
                pub fn Term();
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK11MusicEngine21GetPlayingSegmentInfoEjR13AkSegmentInfob"]
                pub fn GetPlayingSegmentInfo(
                    in_PlayingID: root::AkPlayingID,
                    out_segmentInfo: *mut root::AkSegmentInfo,
                    in_bExtrapolate: bool,
                ) -> root::AKRESULT;
            }
        }
        pub mod Comm {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}__ZN2AK4Comm4InitERK14AkCommSettings"]
                pub fn Init(in_settings: *const root::AkCommSettings) -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK4Comm12GetLastErrorEv"]
                pub fn GetLastError() -> root::AkInt32;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK4Comm22GetDefaultInitSettingsER14AkCommSettings"]
                pub fn GetDefaultInitSettings(out_settings: *mut root::AkCommSettings);
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK4Comm4TermEv"]
                pub fn Term();
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK4Comm5ResetEv"]
                pub fn Reset() -> root::AKRESULT;
            }
            extern "C" {
                #[link_name = "\u{1}__ZN2AK4Comm18GetCurrentSettingsEv"]
                pub fn GetCurrentSettings() -> *const root::AkCommSettings;
            }
        }
    }
    #[repr(u32)]
    #[doc = " Speaker panning type: type of panning logic when object is not 3D spatialized (i.e. when Ak3DSpatializationMode is AK_SpatializationMode_None)."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum AkSpeakerPanningType {
        #[doc = "No panning: route to matching channels between input and output."]
        AK_DirectSpeakerAssignment = 0,
        #[doc = "Balance-Fade-Height: Traditional \"box\" or \"car\"-like panner."]
        AK_BalanceFadeHeight = 1,
        #[doc = "Steering panner."]
        AK_SteeringPanner = 2,
    }
    #[repr(u32)]
    #[doc = " 3D position type: defines what acts as the emitter position for computing spatialization against the listener. Used when Ak3DSpatializationMode is AK_SpatializationMode_PositionOnly or AK_SpatializationMode_PositionAndOrientation."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum Ak3DPositionType {
        #[doc = "3D spatialization is computed directly from the emitter game object position."]
        AK_3DPositionType_Emitter = 0,
        #[doc = "3D spatialization is computed from the emitter game object position, translated by user-defined automation."]
        AK_3DPositionType_EmitterWithAutomation = 1,
        #[doc = "3D spatialization is computed from the listener game object position, translated by user-defined automation."]
        AK_3DPositionType_ListenerWithAutomation = 2,
    }
    #[repr(u32)]
    #[doc = " Headphone / speakers panning rules"]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum AkPanningRule {
        #[doc = "Left and right positioned 60 degrees apart (by default - see AK::SoundEngine::GetSpeakerAngles())."]
        AkPanningRule_Speakers = 0,
        #[doc = "Left and right positioned 180 degrees apart."]
        AkPanningRule_Headphones = 1,
    }
    #[repr(u32)]
    #[doc = " 3D spatialization mode."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum Ak3DSpatializationMode {
        #[doc = "No spatialization"]
        AK_SpatializationMode_None = 0,
        #[doc = "Spatialization based on emitter position only."]
        AK_SpatializationMode_PositionOnly = 1,
        #[doc = "Spatialization based on both emitter position and emitter orientation."]
        AK_SpatializationMode_PositionAndOrientation = 2,
    }
    impl AkBusHierarchyFlags {
        #[doc = "Flag is set to indicate the primary bus hierarchy."]
        pub const AkBusHierarchy_Primary: root::AkBusHierarchyFlags = root::AkBusHierarchyFlags(1);
    }
    impl AkBusHierarchyFlags {
        #[doc = "Flag is set to indicate the secondary bus hierarchy."]
        pub const AkBusHierarchy_Secondary: root::AkBusHierarchyFlags =
            root::AkBusHierarchyFlags(2);
    }
    impl AkBusHierarchyFlags {
        #[doc = "Flag is set to indicate a master bus (may be used in combination with other flags)."]
        pub const AkBusHierarchy_IsMaster: root::AkBusHierarchyFlags =
            root::AkBusHierarchyFlags(128);
    }
    impl ::std::ops::BitOr<root::AkBusHierarchyFlags> for root::AkBusHierarchyFlags {
        type Output = Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            AkBusHierarchyFlags(self.0 | other.0)
        }
    }
    impl ::std::ops::BitOrAssign for root::AkBusHierarchyFlags {
        #[inline]
        fn bitor_assign(&mut self, rhs: root::AkBusHierarchyFlags) {
            self.0 |= rhs.0;
        }
    }
    impl ::std::ops::BitAnd<root::AkBusHierarchyFlags> for root::AkBusHierarchyFlags {
        type Output = Self;
        #[inline]
        fn bitand(self, other: Self) -> Self {
            AkBusHierarchyFlags(self.0 & other.0)
        }
    }
    impl ::std::ops::BitAndAssign for root::AkBusHierarchyFlags {
        #[inline]
        fn bitand_assign(&mut self, rhs: root::AkBusHierarchyFlags) {
            self.0 &= rhs.0;
        }
    }
    #[repr(transparent)]
    #[doc = " Bus type bit field."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct AkBusHierarchyFlags(pub ::std::os::raw::c_uint);
    impl AkMeteringFlags {
        #[doc = "No metering."]
        pub const AK_NoMetering: root::AkMeteringFlags = root::AkMeteringFlags(0);
    }
    impl AkMeteringFlags {
        #[doc = "Enable computation of peak metering."]
        pub const AK_EnableBusMeter_Peak: root::AkMeteringFlags = root::AkMeteringFlags(1);
    }
    impl AkMeteringFlags {
        #[doc = "Enable computation of true peak metering (most CPU and memory intensive)."]
        pub const AK_EnableBusMeter_TruePeak: root::AkMeteringFlags = root::AkMeteringFlags(2);
    }
    impl AkMeteringFlags {
        #[doc = "Enable computation of RMS metering."]
        pub const AK_EnableBusMeter_RMS: root::AkMeteringFlags = root::AkMeteringFlags(4);
    }
    impl AkMeteringFlags {
        #[doc = "Enable computation of K-weighted power metering (used as a basis for computing loudness, as defined by ITU-R BS.1770)."]
        pub const AK_EnableBusMeter_KPower: root::AkMeteringFlags = root::AkMeteringFlags(16);
    }
    impl AkMeteringFlags {
        pub const AK_EnableBusMeter_3DMeter: root::AkMeteringFlags = root::AkMeteringFlags(32);
    }
    impl ::std::ops::BitOr<root::AkMeteringFlags> for root::AkMeteringFlags {
        type Output = Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            AkMeteringFlags(self.0 | other.0)
        }
    }
    impl ::std::ops::BitOrAssign for root::AkMeteringFlags {
        #[inline]
        fn bitor_assign(&mut self, rhs: root::AkMeteringFlags) {
            self.0 |= rhs.0;
        }
    }
    impl ::std::ops::BitAnd<root::AkMeteringFlags> for root::AkMeteringFlags {
        type Output = Self;
        #[inline]
        fn bitand(self, other: Self) -> Self {
            AkMeteringFlags(self.0 & other.0)
        }
    }
    impl ::std::ops::BitAndAssign for root::AkMeteringFlags {
        #[inline]
        fn bitand_assign(&mut self, rhs: root::AkMeteringFlags) {
            self.0 &= rhs.0;
        }
    }
    #[repr(transparent)]
    #[doc = " Metering flags. Used for specifying bus metering, through AK::SoundEngine::RegisterBusVolumeCallback() or AK::IAkMixerPluginContext::SetMeteringFlags()."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct AkMeteringFlags(pub ::std::os::raw::c_uint);
    #[repr(u32)]
    #[doc = " Plug-in type."]
    #[doc = " \\sa"]
    #[doc = " - AkPluginInfo"]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum AkPluginType {
        #[doc = "Unknown/invalid plug-in type."]
        AkPluginTypeNone = 0,
        #[doc = "Compressor/decompressor plug-in (allows support for custom audio file types)."]
        AkPluginTypeCodec = 1,
        #[doc = "Source plug-in: creates sound by synthesis method (no input, just output)."]
        AkPluginTypeSource = 2,
        #[doc = "Effect plug-in: applies processing to audio data."]
        AkPluginTypeEffect = 3,
        #[doc = "Mixer plug-in: mix voices at the bus level."]
        AkPluginTypeMixer = 6,
        #[doc = "Sink plug-in: implement custom sound engine end point."]
        AkPluginTypeSink = 7,
        #[doc = "Global Extension plug-in: (e.g. Spatial Audio, Interactive Music)"]
        AkPluginTypeGlobalExtension = 8,
        #[doc = "Metadata plug-in: applies object-based processing to audio data"]
        AkPluginTypeMetadata = 9,
        #[doc = "Plug-in type mask is 4 bits."]
        AkPluginTypeMask = 15,
    }
    #[repr(u32)]
    #[doc = ""]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub enum AkNodeType {
        AkNodeType_Default = 0,
        AkNodeType_Bus = 1,
    }
    pub mod AkFileParser {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[doc = " Analyzed envelope point."]
        #[repr(C, packed)]
        #[derive(Debug, Copy, Clone)]
        pub struct EnvelopePoint {
            pub uPosition: root::AkUInt32,
            #[doc = " Position of this point in samples at the source rate."]
            pub uAttenuation: root::AkUInt16,
        }
    }
    pub type AkCaptureType = root::AkInt16;
    #[doc = "Channel mask == 0 and channels are anonymous."]
    pub const AkChannelConfigType_AK_ChannelConfigType_Anonymous: root::AkChannelConfigType = 0;
    #[doc = "Channels must be identified with standard defines in AkSpeakerConfigs."]
    pub const AkChannelConfigType_AK_ChannelConfigType_Standard: root::AkChannelConfigType = 1;
    #[doc = "Ambisonics. Channel mask == 0 and channels follow standard ambisonic order."]
    pub const AkChannelConfigType_AK_ChannelConfigType_Ambisonic: root::AkChannelConfigType = 2;
    #[doc = "Object-based configurations."]
    pub const AkChannelConfigType_AK_ChannelConfigType_Objects: root::AkChannelConfigType = 3;
    #[doc = "Special setting for bus objects to use the audio device main configuration."]
    pub const AkChannelConfigType_AK_ChannelConfigType_UseDeviceMain: root::AkChannelConfigType =
        14;
    #[doc = "Special setting for bus objects to use the audio device passthrough configuration."]
    pub const AkChannelConfigType_AK_ChannelConfigType_UseDevicePassthrough:
        root::AkChannelConfigType = 15;
    #[doc = " Channel configuration type."]
    pub type AkChannelConfigType = ::std::os::raw::c_uint;
    #[doc = " Defines a channel configuration."]
    #[doc = " Examples:"]
    #[doc = " \\code"]
    #[doc = " AkChannelConfig cfg;"]
    #[doc = ""]
    #[doc = " // Create a stereo configuration."]
    #[doc = " cfg.SetStandard(AK_SPEAKER_SETUP_STEREO);"]
    #[doc = ""]
    #[doc = " // Create a 7.1.4 configuration (7.1 plus 4 height channels)."]
    #[doc = " cfg.SetStandard(AK_SPEAKER_SETUP_AURO_11POINT1_740);"]
    #[doc = " // or"]
    #[doc = " cfg.SetStandard(AK_SPEAKER_SETUP_DOLBY_7_1_4);"]
    #[doc = ""]
    #[doc = " // Create a 3rd order ambisonic configuration."]
    #[doc = " cfg.SetAmbisonic(16);\t// pass in the number of spherical harmonics, (N+1)^2, where N is the ambisonics order."]
    #[doc = ""]
    #[doc = " // Invalidate (usually means \"As Parent\")"]
    #[doc = " cfg.Clear();"]
    #[doc = " \\endcode"]
    #[repr(C)]
    #[repr(align(4))]
    #[derive(Debug, Copy, Clone)]
    pub struct AkChannelConfig {
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 4usize]>,
    }
    impl AkChannelConfig {
        #[inline]
        pub fn uNumChannels(&self) -> root::AkUInt32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
        }
        #[inline]
        pub fn set_uNumChannels(&mut self, val: root::AkUInt32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 8u8, val as u64)
            }
        }
        #[inline]
        pub fn eConfigType(&self) -> root::AkUInt32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 4u8) as u32) }
        }
        #[inline]
        pub fn set_eConfigType(&mut self, val: root::AkUInt32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(8usize, 4u8, val as u64)
            }
        }
        #[inline]
        pub fn uChannelMask(&self) -> root::AkUInt32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 20u8) as u32) }
        }
        #[inline]
        pub fn set_uChannelMask(&mut self, val: root::AkUInt32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(12usize, 20u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            uNumChannels: root::AkUInt32,
            eConfigType: root::AkUInt32,
            uChannelMask: root::AkUInt32,
        ) -> root::__BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 4usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 8u8, {
                let uNumChannels: u32 = unsafe { ::std::mem::transmute(uNumChannels) };
                uNumChannels as u64
            });
            __bindgen_bitfield_unit.set(8usize, 4u8, {
                let eConfigType: u32 = unsafe { ::std::mem::transmute(eConfigType) };
                eConfigType as u64
            });
            __bindgen_bitfield_unit.set(12usize, 20u8, {
                let uChannelMask: u32 = unsafe { ::std::mem::transmute(uChannelMask) };
                uChannelMask as u64
            });
            __bindgen_bitfield_unit
        }
    }
    pub type AkAtomic32 = i32;
    pub type AkAtomic64 = i64;
    pub type AkAtomicPtr = *mut ::std::os::raw::c_void;
    pub mod AKPLATFORM {
        #[allow(unused_imports)]
        use self::super::super::root;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkThreadProperties {
        #[doc = "Thread priority"]
        pub nPriority: ::std::os::raw::c_int,
        #[doc = "Thread stack size"]
        pub uStackSize: root::size_t,
        #[doc = "Thread scheduling policy"]
        pub uSchedPolicy: ::std::os::raw::c_int,
        #[doc = "Affinity mask"]
        pub dwAffinityMask: root::AkUInt32,
    }
    #[doc = "Generic placeholder for allocations tied to the Wwise project."]
    pub const AkMemID_AkMemID_Object: root::AkMemID = 0;
    #[doc = "Events from the Wwise project."]
    pub const AkMemID_AkMemID_Event: root::AkMemID = 1;
    #[doc = "Structures from the Wwise project."]
    pub const AkMemID_AkMemID_Structure: root::AkMemID = 2;
    #[doc = "Media from the Wwise project."]
    pub const AkMemID_AkMemID_Media: root::AkMemID = 3;
    #[doc = "Game Objects and related."]
    pub const AkMemID_AkMemID_GameObject: root::AkMemID = 4;
    #[doc = "Anything tied to instancing and processing of the DSP graph."]
    pub const AkMemID_AkMemID_Processing: root::AkMemID = 5;
    #[doc = "Plug-in allocations related to the DSP graph."]
    pub const AkMemID_AkMemID_ProcessingPlugin: root::AkMemID = 6;
    #[doc = "Streaming Manager objects."]
    pub const AkMemID_AkMemID_Streaming: root::AkMemID = 7;
    #[doc = "Streaming Manager I/O memory."]
    pub const AkMemID_AkMemID_StreamingIO: root::AkMemID = 8;
    #[doc = "Spatial audio."]
    pub const AkMemID_AkMemID_SpatialAudio: root::AkMemID = 9;
    #[doc = "Spatial audio geometry data."]
    pub const AkMemID_AkMemID_SpatialAudioGeometry: root::AkMemID = 10;
    #[doc = "Spatial audio paths data."]
    pub const AkMemID_AkMemID_SpatialAudioPaths: root::AkMemID = 11;
    #[doc = "Game Simulator allocations."]
    pub const AkMemID_AkMemID_GameSim: root::AkMemID = 12;
    #[doc = "Monitor Queue."]
    pub const AkMemID_AkMemID_MonitorQueue: root::AkMemID = 13;
    #[doc = "Profiler."]
    pub const AkMemID_AkMemID_Profiler: root::AkMemID = 14;
    #[doc = "File packager."]
    pub const AkMemID_AkMemID_FilePackage: root::AkMemID = 15;
    #[doc = "Base sound engine allocations (managers, etc)."]
    pub const AkMemID_AkMemID_SoundEngine: root::AkMemID = 16;
    #[doc = "Game engine integration allocations."]
    pub const AkMemID_AkMemID_Integration: root::AkMemID = 17;
    #[doc = "Category count."]
    pub const AkMemID_AkMemID_NUM: root::AkMemID = 18;
    #[doc = "Mask for category IDs."]
    pub const AkMemID_AkMemID_MASK: root::AkMemID = 536870911;
    #[doc = "Media memory type bit."]
    pub const AkMemID_AkMemType_Media: root::AkMemID = 536870912;
    #[doc = "Device memory type bit."]
    pub const AkMemID_AkMemType_Device: root::AkMemID = 1073741824;
    #[doc = "Do not track this allocation."]
    pub const AkMemID_AkMemType_NoTrack: root::AkMemID = 2147483648;
    #[doc = " Memory category IDs."]
    pub type AkMemID = ::std::os::raw::c_uint;
    #[doc = " Allocator for plugin-friendly arrays (see AkArray)."]
    #[doc = " Usage: Initialize the array with Init(AK::IAkPluginMemAlloc* in_pAllocator), passing it the memory allocator received from the host. Then use normally."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkPluginArrayAllocator {
        pub m_pAllocator: *mut root::AK::IAkPluginMemAlloc,
    }
    #[doc = " Unique structure identifier for AkPlacementNew."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkPlacementNewKey {
        pub _address: u8,
    }
    #[doc = " Unique structure identifier for AkNew."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkPoolNewKey {
        pub _address: u8,
    }
    extern "C" {
        #[link_name = "\u{1}_uBufferSizeBytes"]
        pub static AkHybridAllocator__uBufferSizeBytes: root::AkUInt32;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkAssignmentMovePolicy {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkTransferMovePolicy {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkGrowByPolicy_Legacy {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkGrowByPolicy_NoGrow {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkGrowByPolicy_Proportional {
        pub _address: u8,
    }
    #[doc = " Specific implementation of array"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkArray {
        pub _address: u8,
    }
    #[doc = " Iterator"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkArray_Iterator<T> {
        #[doc = "Pointer to the item in the array."]
        pub pItem: *mut T,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct MapStruct<T_KEY, T_ITEM> {
        pub key: T_KEY,
        pub item: T_ITEM,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_KEY>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_ITEM>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkKeyDataPtrStruct<T_KEY, T_DATA, T_ALLOC> {
        pub _base: T_ALLOC,
        pub key: T_KEY,
        pub pData: *mut T_DATA,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_KEY>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_DATA>>,
        pub _phantom_2: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_ALLOC>>,
    }
    pub type AkHashType = root::AkUInt32;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkHashList {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkHashList_Item<T_KEY, T_ITEM> {
        pub pNextItem: *mut root::AkHashList_Item<T_KEY, T_ITEM>,
        pub Assoc: root::MapStruct<T_KEY, T_ITEM>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_KEY>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_ITEM>>,
    }
    #[doc = " Specific implementation of array"]
    pub type AkHashList_HashTableArray = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkHashList_Iterator<T_KEY, T_ITEM> {
        pub pTable: *mut root::AkHashList_HashTableArray,
        pub uiTable: root::AkHashType,
        pub pItem: *mut root::AkHashList_Item<T_KEY, T_ITEM>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_KEY>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_ITEM>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkHashList_ConstIterator<T_KEY, T_ITEM> {
        pub pTable: *const root::AkHashList_HashTableArray,
        pub uiTable: root::AkHashType,
        pub pItem: *mut root::AkHashList_Item<T_KEY, T_ITEM>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_KEY>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_ITEM>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkHashList_IteratorEx<T_KEY, T_ITEM> {
        pub _base: root::AkHashList_Iterator<T_KEY, T_ITEM>,
        pub pPrevItem: *mut root::AkHashList_Item<T_KEY, T_ITEM>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_KEY>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_ITEM>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkHashList_ConstIteratorEx<T_KEY, T_ITEM> {
        pub _base: root::AkHashList_ConstIterator<T_KEY, T_ITEM>,
        pub pPrevItem: *mut root::AkHashList_Item<T_KEY, T_ITEM>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_KEY>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_ITEM>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkDefaultHashListBarePolicy {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkHashListBare {
        pub _address: u8,
    }
    #[doc = " Specific implementation of array"]
    pub type AkHashListBare_HashTableArray = u8;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkHashListBare_Iterator<T_MAPSTRUCT> {
        pub pTable: *mut root::AkHashListBare_HashTableArray,
        pub uiTable: root::AkHashType,
        pub pItem: *mut T_MAPSTRUCT,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_MAPSTRUCT>>,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkHashListBare_IteratorEx<T_MAPSTRUCT> {
        pub _base: root::AkHashListBare_Iterator<T_MAPSTRUCT>,
        pub pPrevItem: *mut T_MAPSTRUCT,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_MAPSTRUCT>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct AkStringData<TAlloc, T_CHAR> {
        pub _base: TAlloc,
        pub pStr: *const T_CHAR,
        pub bOwner: bool,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<TAlloc>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_CHAR>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct AkStringImpl<TAlloc, T_CHAR> {
        pub _base: root::AkStringData<TAlloc, T_CHAR>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<TAlloc>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_CHAR>>,
    }
    #[repr(C)]
    #[derive(Debug)]
    pub struct AkString<TAlloc, T_CHAR> {
        pub _base: root::AkStringImpl<TAlloc, T_CHAR>,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<TAlloc>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_CHAR>>,
    }
    pub type AkString_tData<TAlloc, T_CHAR> = root::AkStringData<TAlloc, T_CHAR>;
    pub type AkString_tImpl<TAlloc, T_CHAR> = root::AkStringImpl<TAlloc, T_CHAR>;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkNonThreaded {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkDbString {
        pub _address: u8,
    }
    pub type AkDbString_tThis = u8;
    pub type AkDbString_tString<TAlloc, T_CHAR> = root::AkString<TAlloc, T_CHAR>;
    #[repr(C)]
    #[derive(Debug)]
    pub struct AkDbString_Entry<TAlloc, T_CHAR> {
        pub str_: root::AkDbString_tString<TAlloc, T_CHAR>,
        pub refCount: root::AkInt32,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<TAlloc>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T_CHAR>>,
    }
    pub type AkDbString_tStringTable = u8;
    #[repr(C)]
    #[derive(Debug)]
    pub struct AkDbString_Instance<TAlloc, tLock> {
        pub _base: TAlloc,
        pub table: root::AkDbString_tStringTable,
        pub lock: tLock,
        pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<TAlloc>>,
        pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<tLock>>,
    }
    #[doc = "Integer data type (uchar, short, and so on)"]
    pub const AK_INT: root::AkDataTypeID = 0;
    #[doc = "Float data type"]
    pub const AK_FLOAT: root::AkDataTypeID = 1;
    #[doc = "Interleaved data"]
    pub const AK_INTERLEAVED: root::AkDataInterleaveID = 0;
    #[doc = "Non-interleaved data"]
    pub const AK_NONINTERLEAVED: root::AkDataInterleaveID = 1;
    #[doc = "Native number of bits per sample."]
    pub const AK_LE_NATIVE_BITSPERSAMPLE: root::AkUInt32 = 32;
    #[doc = "Native data type."]
    pub const AK_LE_NATIVE_SAMPLETYPE: root::AkUInt32 = 1;
    #[doc = "Native interleaved setting."]
    pub const AK_LE_NATIVE_INTERLEAVE: root::AkUInt32 = 1;
    #[doc = " Defines the parameters of an audio buffer format."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkAudioFormat {
        #[doc = "Number of samples per second"]
        pub uSampleRate: root::AkUInt32,
        #[doc = "Channel configuration."]
        pub channelConfig: root::AkChannelConfig,
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 3usize]>,
    }
    impl AkAudioFormat {
        #[inline]
        pub fn uBitsPerSample(&self) -> root::AkUInt32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 6u8) as u32) }
        }
        #[inline]
        pub fn set_uBitsPerSample(&mut self, val: root::AkUInt32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(0usize, 6u8, val as u64)
            }
        }
        #[inline]
        pub fn uBlockAlign(&self) -> root::AkUInt32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(6usize, 10u8) as u32) }
        }
        #[inline]
        pub fn set_uBlockAlign(&mut self, val: root::AkUInt32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(6usize, 10u8, val as u64)
            }
        }
        #[inline]
        pub fn uTypeID(&self) -> root::AkUInt32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 2u8) as u32) }
        }
        #[inline]
        pub fn set_uTypeID(&mut self, val: root::AkUInt32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(16usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn uInterleaveID(&self) -> root::AkUInt32 {
            unsafe { ::std::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
        }
        #[inline]
        pub fn set_uInterleaveID(&mut self, val: root::AkUInt32) {
            unsafe {
                let val: u32 = ::std::mem::transmute(val);
                self._bitfield_1.set(18usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(
            uBitsPerSample: root::AkUInt32,
            uBlockAlign: root::AkUInt32,
            uTypeID: root::AkUInt32,
            uInterleaveID: root::AkUInt32,
        ) -> root::__BindgenBitfieldUnit<[u8; 3usize]> {
            let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 3usize]> =
                Default::default();
            __bindgen_bitfield_unit.set(0usize, 6u8, {
                let uBitsPerSample: u32 = unsafe { ::std::mem::transmute(uBitsPerSample) };
                uBitsPerSample as u64
            });
            __bindgen_bitfield_unit.set(6usize, 10u8, {
                let uBlockAlign: u32 = unsafe { ::std::mem::transmute(uBlockAlign) };
                uBlockAlign as u64
            });
            __bindgen_bitfield_unit.set(16usize, 2u8, {
                let uTypeID: u32 = unsafe { ::std::mem::transmute(uTypeID) };
                uTypeID as u64
            });
            __bindgen_bitfield_unit.set(18usize, 1u8, {
                let uInterleaveID: u32 = unsafe { ::std::mem::transmute(uInterleaveID) };
                uInterleaveID as u64
            });
            __bindgen_bitfield_unit
        }
    }
    pub type AkChannelMappingFunc = ::std::option::Option<
        unsafe extern "C" fn(
            config: *const root::AkChannelConfig,
            idx: root::AkUInt8,
        ) -> root::AkUInt8,
    >;
    pub const AkSourceChannelOrdering_SourceChannelOrdering_Standard:
        root::AkSourceChannelOrdering = 0;
    pub const AkSourceChannelOrdering_SourceChannelOrdering_Film: root::AkSourceChannelOrdering = 1;
    pub const AkSourceChannelOrdering_SourceChannelOrdering_FuMa: root::AkSourceChannelOrdering = 2;
    pub type AkSourceChannelOrdering = ::std::os::raw::c_uint;
    #[doc = " 3D data needed for 3D spatialization."]
    #[doc = " Undergoes transformations based on emitter-listener placement."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Ak3dData {
        #[doc = "Object position / orientation."]
        pub xform: root::AkTransform,
        #[doc = "Spread [0,1]"]
        pub spread: root::AkReal32,
        #[doc = "Focus [0,1]"]
        pub focus: root::AkReal32,
        #[doc = "Emitter channel mask. With 3D spatialization, zeroed channels should be dropped."]
        pub uEmitterChannelMask: root::AkChannelMask,
    }
    #[doc = " Positioning data inherited from sound structures and mix busses."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkBehavioralPositioningData {
        #[doc = "Center percentage [0,1]"]
        pub center: root::AkReal32,
        #[doc = "Pan left-right [-1,1]"]
        pub panLR: root::AkReal32,
        #[doc = "Pan back-front [-1,1]"]
        pub panBF: root::AkReal32,
        #[doc = "Pan down-up [-1,1]"]
        pub panDU: root::AkReal32,
        #[doc = "Panning vs 3D spatialization mix ([0,1], 1 being 100% spatialized)."]
        pub panSpatMix: root::AkReal32,
        #[doc = "3D spatialization mode."]
        pub spatMode: root::Ak3DSpatializationMode,
        #[doc = "Speaker panning type."]
        pub panType: root::AkSpeakerPanningType,
        #[doc = "When true, audio objects 3D spatialized onto a planar channel configuration will be given a minimum spread value based on their elevation angle, equal to sin(elevation)**2."]
        pub enableHeightSpread: bool,
    }
    #[doc = " Positioning data of 3D audio objects."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkPositioningData {
        #[doc = "3D data used for 3D spatialization."]
        pub threeD: root::Ak3dData,
        #[doc = "Positioning data inherited from sound structures and mix busses."]
        pub behavioral: root::AkBehavioralPositioningData,
    }
    #[doc = " An audio object refers to an audio signal with some attached metadata going through the sound engine pipeline."]
    #[doc = " The AkAudioObject struct encapsulates the metadata part. The signal itself is contained in a separate AkAudioBuffer instance."]
    #[repr(C)]
    #[derive(Debug)]
    pub struct AkAudioObject {
        #[doc = "Unique ID, local to a given bus."]
        pub key: root::AkAudioObjectID,
        #[doc = "Positioning data for deferred 3D rendering."]
        pub positioning: root::AkPositioningData,
        #[doc = "Cumulative ramping gain to apply when mixing down to speaker bed or final endpoint"]
        pub cumulativeGain: root::AkRamp,
        #[doc = "Array of custom metadata, gathered from visited objects."]
        pub arCustomMetadata: root::AkAudioObject_ArrayCustomMetadata,
        #[doc = "Profiling ID of the node from which the object stems (typically the voice, instance of an actor-mixer)."]
        pub instigatorID: root::AkPipelineID,
        #[doc = "Name string of the object, to appear in the object profiler. This is normally used by out-of-place object processors for naming their output objects. Built-in sound engine structures don't use it."]
        pub objectName: root::AkAudioObject_String,
    }
    #[doc = " Custom object metadata."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkAudioObject_CustomMetadata {
        #[doc = "Full plugin ID (including company ID and plugin type. See AKMAKECLASSID macro."]
        pub pluginID: root::AkPluginID,
        #[doc = "Custom, pluggable medata."]
        pub pParam: *mut root::AK::IAkPluginParam,
        #[doc = "(Profiling) ID of the sound or bus from which the custom metadata was fetched."]
        pub contextID: root::AkUniqueID,
    }
    #[doc = " Specific implementation of array"]
    pub type AkAudioObject_ArrayCustomMetadata = [u64; 3usize];
    pub type AkAudioObject_String =
        root::AkString<root::AkPluginArrayAllocator, ::std::os::raw::c_char>;
    #[doc = " Structure containing information about system-level support for 3D audio."]
    #[doc = " \"3D Audio\" refers to a system's ability to position sound sources in a virtual 3D space, pan them accordingly on a range of physical speakers, and produce a binaural mix where appropriate."]
    #[doc = " We prefer \"3D Audio\" to \"Spatial\" to avoid ambiguity with spatial audio, which typically involves sound propagation and environment effects."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct Ak3DAudioSinkCapabilities {
        pub channelConfig: root::AkChannelConfig,
        #[doc = " Channel configuration of the main mix."]
        pub uMaxSystemAudioObjects: root::AkUInt32,
        #[doc = " Maximum number of System Audio Objects that can be active concurrently. A value of zero indicates the system does not support this feature."]
        pub uAvailableSystemAudioObjects: root::AkUInt32,
        #[doc = " How many System Audio Objects can currently be sent to the sink. This value can change at runtime depending on what is playing. Can never be higher than uMaxSystemAudioObjects."]
        pub bPassthrough: bool,
        #[doc = " Separate  pass-through mix is supported."]
        pub bMultiChannelObjects: bool,
    }
    pub const AkAudioObjectDestination_eDefault: root::AkAudioObjectDestination = 0;
    pub const AkAudioObjectDestination_eMainMix: root::AkAudioObjectDestination = 1;
    pub const AkAudioObjectDestination_ePassthrough: root::AkAudioObjectDestination = 2;
    pub const AkAudioObjectDestination_eSystemAudioObject: root::AkAudioObjectDestination = 3;
    #[doc = " Enum of the possible object destinations when reaching a 3D audio-capable sink"]
    pub type AkAudioObjectDestination = ::std::os::raw::c_int;
    #[doc = " Native sample type."]
    #[doc = " \\remarks Sample values produced by insert effects must use this type."]
    #[doc = " \\remarks Source plug-ins can produce samples of other types (specified through"]
    #[doc = " according fields of AkAudioFormat, at initial handshaking), but these will be"]
    #[doc = " format converted internally into the native format."]
    #[doc = " \\sa"]
    #[doc = " - \\ref iaksourceeffect_init"]
    #[doc = " - \\ref iakmonadiceffect_init"]
    pub type AkSampleType = root::AkReal32;
    #[doc = " Audio buffer structure including the address of an audio buffer, the number of valid frames inside,"]
    #[doc = " and the maximum number of frames the audio buffer can hold."]
    #[doc = " \\sa"]
    #[doc = " - \\ref fx_audiobuffer_struct"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkAudioBuffer {
        #[doc = "Start of the audio buffer."]
        pub pData: *mut ::std::os::raw::c_void,
        #[doc = "Channel config."]
        pub channelConfig: root::AkChannelConfig,
        #[doc = "Execution status"]
        pub eState: root::AKRESULT,
        #[doc = "Number of sample frames the buffer can hold. Access through AkAudioBuffer::MaxFrames()."]
        pub uMaxFrames: root::AkUInt16,
        #[doc = "Number of valid sample frames in the audio buffer"]
        pub uValidFrames: root::AkUInt16,
    }
    extern "C" {
        #[link_name = "\u{1}__ZN13AkAudioBuffer17CheckValidSamplesEv"]
        pub fn AkAudioBuffer_CheckValidSamples(this: *mut root::AkAudioBuffer) -> bool;
    }
    impl AkAudioBuffer {
        #[inline]
        pub unsafe fn CheckValidSamples(&mut self) -> bool {
            AkAudioBuffer_CheckValidSamples(self)
        }
    }
    #[doc = " A collection of audio objects. Encapsulates the audio data and metadata of each audio object in separate arrays."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkAudioObjects {
        #[doc = "Number of audio objects."]
        pub uNumObjects: root::AkUInt32,
        #[doc = "Array of pointers to audio object buffers."]
        pub ppObjectBuffers: *mut *mut root::AkAudioBuffer,
        #[doc = "Array of pointers to audio objects."]
        pub ppObjects: *mut *mut root::AkAudioObject,
    }
    pub type AkMidiChannelNo = root::AkUInt8;
    pub type AkMidiNoteNo = root::AkUInt8;
    #[doc = "Not a valid midi channel"]
    pub const AK_INVALID_MIDI_CHANNEL: root::AkMidiChannelNo = 255;
    #[doc = "Not a valid midi note"]
    pub const AK_INVALID_MIDI_NOTE: root::AkMidiNoteNo = 255;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct AkMIDIEvent {
        #[doc = "See AK_MIDI_EVENT_TYPE_* pre-processor definitions"]
        pub byType: root::AkUInt8,
        pub byChan: root::AkMidiChannelNo,
        pub __bindgen_anon_1: root::AkMIDIEvent__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMIDIEvent_tGen {
        pub byParam1: root::AkUInt8,
        pub byParam2: root::AkUInt8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMIDIEvent_tNoteOnOff {
        pub byNote: root::AkMidiNoteNo,
        pub byVelocity: root::AkUInt8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMIDIEvent_tCc {
        pub byCc: root::AkUInt8,
        pub byValue: root::AkUInt8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMIDIEvent_tPitchBend {
        pub byValueLsb: root::AkUInt8,
        pub byValueMsb: root::AkUInt8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMIDIEvent_tNoteAftertouch {
        pub byNote: root::AkUInt8,
        pub byValue: root::AkUInt8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMIDIEvent_tChanAftertouch {
        pub byValue: root::AkUInt8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMIDIEvent_tProgramChange {
        pub byProgramNum: root::AkUInt8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMIDIEvent_tWwiseCmd {
        #[doc = "See AK_MIDI_WWISE_CMD_* pre-processor definitions"]
        pub uCmd: root::AkUInt16,
        #[doc = "Optional argument for some commands"]
        pub uArg: root::AkUInt32,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union AkMIDIEvent__bindgen_ty_1 {
        pub Gen: root::AkMIDIEvent_tGen,
        pub Cc: root::AkMIDIEvent_tCc,
        pub NoteOnOff: root::AkMIDIEvent_tNoteOnOff,
        pub PitchBend: root::AkMIDIEvent_tPitchBend,
        pub NoteAftertouch: root::AkMIDIEvent_tNoteAftertouch,
        pub ChanAftertouch: root::AkMIDIEvent_tChanAftertouch,
        pub ProgramChange: root::AkMIDIEvent_tProgramChange,
        pub WwiseCmd: root::AkMIDIEvent_tWwiseCmd,
    }
    #[repr(C, packed(4))]
    #[derive(Copy, Clone)]
    pub struct AkMIDIPost {
        pub _base: root::AkMIDIEvent,
        #[doc = "Frame offset (in samples) for MIDI event post"]
        pub uOffset: root::AkUInt64,
    }
    impl AkCallbackType {
        #[doc = "Callback triggered when reaching the end of an event. AkCallbackInfo can be cast to AkEventCallbackInfo."]
        pub const AK_EndOfEvent: root::AkCallbackType = root::AkCallbackType(1);
    }
    impl AkCallbackType {
        #[doc = "Callback triggered when reaching the end of a dynamic sequence item. AkCallbackInfo can be cast to AkDynamicSequenceItemCallbackInfo."]
        pub const AK_EndOfDynamicSequenceItem: root::AkCallbackType = root::AkCallbackType(2);
    }
    impl AkCallbackType {
        #[doc = "Callback triggered when encountering a marker during playback. AkCallbackInfo can be cast to AkMarkerCallbackInfo."]
        pub const AK_Marker: root::AkCallbackType = root::AkCallbackType(4);
    }
    impl AkCallbackType {
        #[doc = "Callback triggered when the duration of the sound is known by the sound engine. AkCallbackInfo can be cast to AkDurationCallbackInfo."]
        pub const AK_Duration: root::AkCallbackType = root::AkCallbackType(8);
    }
    impl AkCallbackType {
        #[doc = "Callback triggered at each frame, letting the client modify the speaker volume matrix. AkCallbackInfo can be cast to AkSpeakerVolumeMatrixCallbackInfo."]
        pub const AK_SpeakerVolumeMatrix: root::AkCallbackType = root::AkCallbackType(16);
    }
    impl AkCallbackType {
        #[doc = "Callback triggered when playback skips a frame due to stream starvation. AkCallbackInfo can be cast to AkEventCallbackInfo."]
        pub const AK_Starvation: root::AkCallbackType = root::AkCallbackType(32);
    }
    impl AkCallbackType {
        #[doc = "Callback triggered when music playlist container must select the next item to play. AkCallbackInfo can be cast to AkMusicPlaylistCallbackInfo."]
        pub const AK_MusicPlaylistSelect: root::AkCallbackType = root::AkCallbackType(64);
    }
    impl AkCallbackType {
        #[doc = "Callback triggered when a \"Play\" or \"Seek\" command has been executed (\"Seek\" commands are issued from AK::SoundEngine::SeekOnEvent()). Applies to objects of the Interactive-Music Hierarchy only. AkCallbackInfo can be cast to AkEventCallbackInfo."]
        pub const AK_MusicPlayStarted: root::AkCallbackType = root::AkCallbackType(128);
    }
    impl AkCallbackType {
        #[doc = "Enable notifications on Music Beat. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo."]
        pub const AK_MusicSyncBeat: root::AkCallbackType = root::AkCallbackType(256);
    }
    impl AkCallbackType {
        #[doc = "Enable notifications on Music Bar. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo."]
        pub const AK_MusicSyncBar: root::AkCallbackType = root::AkCallbackType(512);
    }
    impl AkCallbackType {
        #[doc = "Enable notifications on Music Entry Cue. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo."]
        pub const AK_MusicSyncEntry: root::AkCallbackType = root::AkCallbackType(1024);
    }
    impl AkCallbackType {
        #[doc = "Enable notifications on Music Exit Cue. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo."]
        pub const AK_MusicSyncExit: root::AkCallbackType = root::AkCallbackType(2048);
    }
    impl AkCallbackType {
        #[doc = "Enable notifications on Music Grid. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo."]
        pub const AK_MusicSyncGrid: root::AkCallbackType = root::AkCallbackType(4096);
    }
    impl AkCallbackType {
        #[doc = "Enable notifications on Music Custom Cue. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo."]
        pub const AK_MusicSyncUserCue: root::AkCallbackType = root::AkCallbackType(8192);
    }
    impl AkCallbackType {
        #[doc = "Enable notifications on Music switch transition synchronization point. AkCallbackInfo can be cast to AkMusicSyncCallbackInfo."]
        pub const AK_MusicSyncPoint: root::AkCallbackType = root::AkCallbackType(16384);
    }
    impl AkCallbackType {
        #[doc = "Use this flag if you want to receive all notifications concerning AK_MusicSync registration."]
        pub const AK_MusicSyncAll: root::AkCallbackType = root::AkCallbackType(32512);
    }
    impl AkCallbackType {
        #[doc = "Enable notifications for MIDI events. AkCallbackInfo can be cast to AkMIDIEventCallbackInfo."]
        pub const AK_MIDIEvent: root::AkCallbackType = root::AkCallbackType(65536);
    }
    impl AkCallbackType {
        #[doc = "Bitmask for all callback types."]
        pub const AK_CallbackBits: root::AkCallbackType = root::AkCallbackType(1048575);
    }
    impl AkCallbackType {
        #[doc = "Enable play position information for use by AK::SoundEngine::GetSourcePlayPosition()."]
        pub const AK_EnableGetSourcePlayPosition: root::AkCallbackType =
            root::AkCallbackType(1048576);
    }
    impl AkCallbackType {
        #[doc = "Enable play position information of music objects, queried via AK::MusicEngine::GetPlayingSegmentInfo()."]
        pub const AK_EnableGetMusicPlayPosition: root::AkCallbackType =
            root::AkCallbackType(2097152);
    }
    impl AkCallbackType {
        #[doc = "Enable stream buffering information for use by AK::SoundEngine::GetSourceStreamBuffering()."]
        pub const AK_EnableGetSourceStreamBuffering: root::AkCallbackType =
            root::AkCallbackType(4194304);
    }
    impl ::std::ops::BitOr<root::AkCallbackType> for root::AkCallbackType {
        type Output = Self;
        #[inline]
        fn bitor(self, other: Self) -> Self {
            AkCallbackType(self.0 | other.0)
        }
    }
    impl ::std::ops::BitOrAssign for root::AkCallbackType {
        #[inline]
        fn bitor_assign(&mut self, rhs: root::AkCallbackType) {
            self.0 |= rhs.0;
        }
    }
    impl ::std::ops::BitAnd<root::AkCallbackType> for root::AkCallbackType {
        type Output = Self;
        #[inline]
        fn bitand(self, other: Self) -> Self {
            AkCallbackType(self.0 & other.0)
        }
    }
    impl ::std::ops::BitAndAssign for root::AkCallbackType {
        #[inline]
        fn bitand_assign(&mut self, rhs: root::AkCallbackType) {
            self.0 &= rhs.0;
        }
    }
    #[repr(transparent)]
    #[doc = " Type of callback. Used as a bitfield in methods AK::SoundEngine::PostEvent() and AK::SoundEngine::DynamicSequence::Open()."]
    #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
    pub struct AkCallbackType(pub ::std::os::raw::c_uint);
    #[doc = " Callback information structure used as base for all notifications handled by \\ref AkCallbackFunc."]
    #[doc = " \\sa"]
    #[doc = " - AK::SoundEngine::PostEvent()"]
    #[doc = " - \\ref soundengine_events"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkCallbackInfo {
        #[doc = "User data, passed to PostEvent()"]
        pub pCookie: *mut ::std::os::raw::c_void,
        #[doc = "Game object ID"]
        pub gameObjID: root::AkGameObjectID,
    }
    #[doc = " Callback information structure corresponding to \\ref AK_EndOfEvent, \\ref AK_MusicPlayStarted and \\ref AK_Starvation."]
    #[doc = " \\sa"]
    #[doc = " - AK::SoundEngine::PostEvent()"]
    #[doc = " - \\ref soundengine_events"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkEventCallbackInfo {
        pub _base: root::AkCallbackInfo,
        #[doc = "Playing ID of Event, returned by PostEvent()"]
        pub playingID: root::AkPlayingID,
        #[doc = "Unique ID of Event, passed to PostEvent()"]
        pub eventID: root::AkUniqueID,
    }
    #[doc = " Callback information structure corresponding to \\ref AkCallbackType::AK_MIDIEvent"]
    #[doc = " \\sa"]
    #[doc = " - AK::SoundEngine::PostEvent()"]
    #[doc = " - \\ref soundengine_events"]
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct AkMIDIEventCallbackInfo {
        pub _base: root::AkEventCallbackInfo,
        #[doc = "MIDI event triggered by event."]
        pub midiEvent: root::AkMIDIEvent,
    }
    #[doc = " Callback information structure corresponding to \\ref AK_Marker."]
    #[doc = " \\sa"]
    #[doc = " - AK::SoundEngine::PostEvent()"]
    #[doc = " - \\ref soundengine_events"]
    #[doc = " - \\ref soundengine_markers"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMarkerCallbackInfo {
        pub _base: root::AkEventCallbackInfo,
        #[doc = "Cue point identifier"]
        pub uIdentifier: root::AkUInt32,
        #[doc = "Position in the cue point (unit: sample frames)"]
        pub uPosition: root::AkUInt32,
        #[doc = "Label of the marker, read from the file"]
        pub strLabel: *const ::std::os::raw::c_char,
    }
    #[doc = " Callback information structure corresponding to \\ref AK_Duration."]
    #[doc = " \\sa"]
    #[doc = " - AK::SoundEngine::PostEvent()"]
    #[doc = " - \\ref soundengine_events"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkDurationCallbackInfo {
        pub _base: root::AkEventCallbackInfo,
        #[doc = "Duration of the sound (unit: milliseconds)"]
        pub fDuration: root::AkReal32,
        #[doc = "Estimated duration of the sound depending on source settings such as pitch. (unit: milliseconds)"]
        pub fEstimatedDuration: root::AkReal32,
        #[doc = "Audio Node ID of playing item"]
        pub audioNodeID: root::AkUniqueID,
        #[doc = "Media ID of playing item. (corresponds to 'ID' attribute of 'File' element in SoundBank metadata file)"]
        pub mediaID: root::AkUniqueID,
        #[doc = "True if source is streaming, false otherwise."]
        pub bStreaming: bool,
    }
    #[doc = " Callback information structure corresponding to \\ref AK_EndOfDynamicSequenceItem."]
    #[doc = " \\sa"]
    #[doc = " - AK::SoundEngine::PostEvent()"]
    #[doc = " - AK::SoundEngine::DynamicSequence::Open()"]
    #[doc = " - \\ref soundengine_events"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkDynamicSequenceItemCallbackInfo {
        pub _base: root::AkCallbackInfo,
        #[doc = "Playing ID of Dynamic Sequence, returned by AK::SoundEngine:DynamicSequence::Open()"]
        pub playingID: root::AkPlayingID,
        #[doc = "Audio Node ID of finished item"]
        pub audioNodeID: root::AkUniqueID,
        #[doc = "Custom info passed to the DynamicSequence::Open function"]
        pub pCustomInfo: *mut ::std::os::raw::c_void,
    }
    #[doc = " Callback information structure corresponding to \\ref AK_SpeakerVolumeMatrix, and passed to callbacks registered in RegisterBusVolumeCallback()"]
    #[doc = " or PostEvent() with AK_SpeakerVolumeMatrix. These callbacks are called at every audio frame for every connection from an input (voice"]
    #[doc = " or bus) to an output bus (standard or auxiliary), at the point when an input signal is about to be mixed into a mixing bus, but just before"]
    #[doc = " having been scaled in accordance to volumes authored in Wwise. The volumes are passed via this structure as pointers because they can be modified"]
    #[doc = " in the callbacks. They are factored into two linear values ([0..1]): a common base value (pfBaseVolume), that is channel-agnostic and represents"]
    #[doc = " the collapsed gain of all volume changes in Wwise (sliders, actions, RTPC, attenuations, ...), and a matrix of gains per input/output channel,"]
    #[doc = " which depends on spatialization. Use the methods of AK::SpeakerVolumes::Matrix, defined in AkCommonDefs.h, to perform operations on them."]
    #[doc = " Access each input channel of the volumes matrix with AK::SpeakerVolumes::Matrix::GetChannel(), passing it the input and output channel configuration."]
    #[doc = " Then, you may access each element of the output vector using the standard bracket [] operator. See AK::SpeakerVolumes for more details."]
    #[doc = " It is crucial that the processing done in the callback be lightweight and non-blocking."]
    #[doc = " \\sa"]
    #[doc = " - \\ref goingfurther_speakermatrixcallback"]
    #[doc = " - AK::SoundEngine::PostEvent()"]
    #[doc = " - \\ref soundengine_events"]
    #[doc = " - AK::SoundEngine::RegisterBusVolumeCallback()"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkSpeakerVolumeMatrixCallbackInfo {
        pub _base: root::AkEventCallbackInfo,
        #[doc = "Pointer to volume matrix describing the contribution of each source channel to destination channels. Use methods of AK::SpeakerVolumes::Matrix to interpret them."]
        pub pVolumes: root::AK::SpeakerVolumes::MatrixPtr,
        #[doc = "Channel configuration of the voice/bus."]
        pub inputConfig: root::AkChannelConfig,
        #[doc = "Channel configuration of the output bus."]
        pub outputConfig: root::AkChannelConfig,
        #[doc = "Base volume, common to all channels."]
        pub pfBaseVolume: *mut root::AkReal32,
        #[doc = "Emitter-listener pair-specific gain. When there are multiple emitter-listener pairs, this volume is set to that of the loudest pair, and the relative gain of other pairs is applied directly on the channel volume matrix pVolumes."]
        pub pfEmitterListenerVolume: *mut root::AkReal32,
        #[doc = "Context of the current voice/bus about to be mixed into the output bus with specified base volume and volume matrix."]
        pub pContext: *mut root::AK::IAkMixerInputContext,
        #[doc = "Output mixing bus context. Use it to access a few useful panning and mixing services, as well as the ID of the output bus. NULL if pContext is the master audio bus."]
        pub pMixerContext: *mut root::AK::IAkMixerPluginContext,
    }
    #[doc = " Callback information structure allowing to query signal metering on busses, at each frame, after having mixed all their inputs and processed their effects."]
    #[doc = " Register the callback using AK::SoundEngine::RegisterBusMeteringCallback."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkBusMeteringCallbackInfo {
        pub _base: root::AkCallbackInfo,
        #[doc = "AK::IAkMetering interface for retrieving metering information."]
        pub pMetering: *mut root::AK::IAkMetering,
        #[doc = "Channel configuration of the bus."]
        pub channelConfig: root::AkChannelConfig,
        #[doc = "Metering flags that were asked for in RegisterBusMeteringCallback(). You may only access corresponding meter values from in_pMeteringInfo. Others will fail."]
        pub eMeteringFlags: root::AkMeteringFlags,
    }
    #[doc = " Callback information structure allowing to query signal metering on output devices, at each frame."]
    #[doc = " Register the callback using AK::SoundEngine::RegisterOutputDeviceMeteringCallback."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkOutputDeviceMeteringCallbackInfo {
        pub _base: root::AkCallbackInfo,
        #[doc = "Metering information for the main mix"]
        pub pMainMixMetering: *mut root::AK::IAkMetering,
        #[doc = "Channel configuration of the main mix"]
        pub mainMixConfig: root::AkChannelConfig,
        #[doc = "Metering information for the passthrough mix (if any; will be null otherwise)"]
        pub pPassthroughMetering: *mut root::AK::IAkMetering,
        #[doc = "Channel configuration of the passthrough mix (if any; will be invalid otherwise)"]
        pub passthroughMixConfig: root::AkChannelConfig,
        #[doc = "Number of System Audio Objects going out of the output device"]
        pub uNumSystemAudioObjects: root::AkUInt32,
        #[doc = "Metering information for each System Audio Object (number of elements is equal to uNumSystemAudioObjects)"]
        pub ppSystemAudioObjectMetering: *mut *mut root::AK::IAkMetering,
        #[doc = "Metering flags that were asked for in RegisterOutputDeviceMeteringCallback(). You may only access corresponding meter values from the metering objects. Others will fail."]
        pub eMeteringFlags: root::AkMeteringFlags,
    }
    #[doc = " Callback information structure corresponding to \\ref AK_MusicPlaylistSelect."]
    #[doc = " Called when a music playlist container must select its next item to play."]
    #[doc = " The members uPlaylistSelection and uPlaylistItemDone are set by the sound"]
    #[doc = " engine before the callback function call.  They are set to the next item"]
    #[doc = " selected by the sound engine.  They are to be modified by the callback"]
    #[doc = " function if the selection is to be changed."]
    #[doc = " \\sa"]
    #[doc = " - \\ref soundengine_events"]
    #[doc = " - AK::SoundEngine::PostEvent()"]
    #[doc = " - \\ref soundengine_music_callbacks"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMusicPlaylistCallbackInfo {
        pub _base: root::AkEventCallbackInfo,
        #[doc = "ID of playlist node"]
        pub playlistID: root::AkUniqueID,
        #[doc = "Number of items in playlist node (may be segments or other playlists)"]
        pub uNumPlaylistItems: root::AkUInt32,
        #[doc = "Selection: set by sound engine, modified by callback function (if not in range 0 <= uPlaylistSelection < uNumPlaylistItems then ignored)."]
        pub uPlaylistSelection: root::AkUInt32,
        #[doc = "Playlist node done: set by sound engine, modified by callback function (if set to anything but 0 then the current playlist item is done, and uPlaylistSelection is ignored)"]
        pub uPlaylistItemDone: root::AkUInt32,
    }
    #[doc = " Structure used to query info on active playing segments."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkSegmentInfo {
        #[doc = "Current position of the segment, relative to the Entry Cue, in milliseconds. Range is [-iPreEntryDuration, iActiveDuration+iPostExitDuration]."]
        pub iCurrentPosition: root::AkTimeMs,
        #[doc = "Duration of the pre-entry region of the segment, in milliseconds."]
        pub iPreEntryDuration: root::AkTimeMs,
        #[doc = "Duration of the active region of the segment (between the Entry and Exit Cues), in milliseconds."]
        pub iActiveDuration: root::AkTimeMs,
        #[doc = "Duration of the post-exit region of the segment, in milliseconds."]
        pub iPostExitDuration: root::AkTimeMs,
        #[doc = "Number of milliseconds remaining in the \"looking-ahead\" state of the segment, when it is silent but streamed tracks are being prefetched."]
        pub iRemainingLookAheadTime: root::AkTimeMs,
        #[doc = "Beat Duration in seconds."]
        pub fBeatDuration: root::AkReal32,
        #[doc = "Bar Duration in seconds."]
        pub fBarDuration: root::AkReal32,
        #[doc = "Grid duration in seconds."]
        pub fGridDuration: root::AkReal32,
        #[doc = "Grid offset in seconds."]
        pub fGridOffset: root::AkReal32,
    }
    #[doc = " Callback information structure corresponding to \\ref AK_MusicSyncEntry, \\ref AK_MusicSyncBeat, \\ref AK_MusicSyncBar, \\ref AK_MusicSyncExit, \\ref AK_MusicSyncGrid, \\ref AK_MusicSyncPoint and \\ref AK_MusicSyncUserCue."]
    #[doc = " If you need the Tempo, you can compute it using the fBeatDuration"]
    #[doc = " Tempo (beats per minute) = 60/fBeatDuration"]
    #[doc = " \\sa"]
    #[doc = " - \\ref soundengine_events"]
    #[doc = " - AK::SoundEngine::PostEvent()"]
    #[doc = " - \\ref soundengine_music_callbacks"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMusicSyncCallbackInfo {
        pub _base: root::AkCallbackInfo,
        #[doc = "Playing ID of Event, returned by PostEvent()"]
        pub playingID: root::AkPlayingID,
        #[doc = "Segment information corresponding to the segment triggering this callback."]
        pub segmentInfo: root::AkSegmentInfo,
        #[doc = "Would be either \\ref AK_MusicSyncEntry, \\ref AK_MusicSyncBeat, \\ref AK_MusicSyncBar, \\ref AK_MusicSyncExit, \\ref AK_MusicSyncGrid, \\ref AK_MusicSyncPoint or \\ref AK_MusicSyncUserCue."]
        pub musicSyncType: root::AkCallbackType,
        #[doc = "Cue name (UTF-8 string). Set for notifications AK_MusicSyncUserCue. NULL if cue has no name."]
        pub pszUserCueName: *mut ::std::os::raw::c_char,
    }
    #[doc = " Resources data summary structure containing general information about the system"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkResourceMonitorDataSummary {
        #[doc = "Pourcentage of the cpu time used for processing audio. Please note that the numbers may add up when using multiple threads."]
        pub totalCPU: root::AkReal32,
        #[doc = "Pourcentage of the cpu time used by plugin processing. Please note that the numbers may add up when using multiple threads."]
        pub pluginCPU: root::AkReal32,
        #[doc = "Number of active physical voices"]
        pub physicalVoices: root::AkUInt32,
        #[doc = "Number of active virtual voices"]
        pub virtualVoices: root::AkUInt32,
        #[doc = "Number of active physical and virtual voices"]
        pub totalVoices: root::AkUInt32,
        #[doc = "Number of events triggered at a certain time"]
        pub nbActiveEvents: root::AkUInt32,
    }
    pub type AkCallbackFunc = ::std::option::Option<
        unsafe extern "C" fn(
            in_eType: root::AkCallbackType,
            in_pCallbackInfo: *mut root::AkCallbackInfo,
        ),
    >;
    pub type AkBusCallbackFunc = ::std::option::Option<
        unsafe extern "C" fn(in_pCallbackInfo: *mut root::AkSpeakerVolumeMatrixCallbackInfo),
    >;
    pub type AkBusMeteringCallbackFunc = ::std::option::Option<
        unsafe extern "C" fn(in_pCallbackInfo: *mut root::AkBusMeteringCallbackInfo),
    >;
    pub type AkOutputDeviceMeteringCallbackFunc = ::std::option::Option<
        unsafe extern "C" fn(in_pCallbackInfo: *mut root::AkOutputDeviceMeteringCallbackInfo),
    >;
    pub type AkBankCallbackFunc = ::std::option::Option<
        unsafe extern "C" fn(
            in_bankID: root::AkUInt32,
            in_pInMemoryBankPtr: *const ::std::os::raw::c_void,
            in_eLoadResult: root::AKRESULT,
            in_pCookie: *mut ::std::os::raw::c_void,
        ),
    >;
    #[doc = "Right after successful registration of callback/plugin. Typically used by plugins along with AkGlobalCallbackLocation_Term for allocating memory for the lifetime of the sound engine."]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_Register:
        root::AkGlobalCallbackLocation = 1;
    #[doc = "Start of audio processing. The number of frames about to be rendered depends on the sink/end-point and can be zero."]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_Begin:
        root::AkGlobalCallbackLocation = 2;
    #[doc = "Start of frame rendering, before having processed game messages."]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_PreProcessMessageQueueForRender:
        root::AkGlobalCallbackLocation = 4;
    #[doc = "After one or more messages have been processed, but before updating game object and listener positions internally."]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_PostMessagesProcessed:
        root::AkGlobalCallbackLocation = 8;
    #[doc = "Start of frame rendering, after having processed game messages."]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_BeginRender:
        root::AkGlobalCallbackLocation = 16;
    #[doc = "End of frame rendering."]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_EndRender:
        root::AkGlobalCallbackLocation = 32;
    #[doc = "End of audio processing."]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_End:
        root::AkGlobalCallbackLocation = 64;
    #[doc = "Sound engine termination."]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_Term:
        root::AkGlobalCallbackLocation = 128;
    #[doc = "Send monitor data"]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_Monitor:
        root::AkGlobalCallbackLocation = 256;
    #[doc = "Send monitor data connection to recap."]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_MonitorRecap:
        root::AkGlobalCallbackLocation = 512;
    #[doc = "Sound engine initialization."]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_Init:
        root::AkGlobalCallbackLocation = 1024;
    #[doc = "Sound engine suspension through \\ref AK::SoundEngine::Suspend"]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_Suspend:
        root::AkGlobalCallbackLocation = 2048;
    #[doc = "Sound engine awakening through \\ref AK::SoundEngine::WakeupFromSuspend"]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_WakeupFromSuspend:
        root::AkGlobalCallbackLocation = 4096;
    #[doc = "Total number of global callback locations."]
    pub const AkGlobalCallbackLocation_AkGlobalCallbackLocation_Num:
        root::AkGlobalCallbackLocation = 13;
    #[doc = " Bit field of various locations in the audio processing loop where the game can be called back."]
    pub type AkGlobalCallbackLocation = ::std::os::raw::c_uint;
    pub type AkGlobalCallbackFunc = ::std::option::Option<
        unsafe extern "C" fn(
            in_pContext: *mut root::AK::IAkGlobalPluginContext,
            in_eLocation: root::AkGlobalCallbackLocation,
            in_pCookie: *mut ::std::os::raw::c_void,
        ),
    >;
    pub type AkResourceMonitorCallbackFunc = ::std::option::Option<
        unsafe extern "C" fn(in_pdataSummary: *const root::AkResourceMonitorDataSummary),
    >;
    pub type AkCaptureCallbackFunc = ::std::option::Option<
        unsafe extern "C" fn(
            in_CaptureBuffer: *mut root::AkAudioBuffer,
            in_idOutput: root::AkOutputDeviceID,
            in_pCookie: *mut ::std::os::raw::c_void,
        ),
    >;
    #[doc = " Plug-in information structure."]
    #[doc = " \\remarks The bIsInPlace field is only relevant for effect plug-ins."]
    #[doc = " \\sa"]
    #[doc = " - \\ref iakeffect_geteffectinfo"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkPluginInfo {
        #[doc = "Plug-in type"]
        pub eType: root::AkPluginType,
        #[doc = "Plug-in build version, must match the AK_WWISESDK_VERSION_COMBINED macro from AkWwiseSDKVersion.h.  Prevents usage of plugins compiled for other versions, avoiding crashes or data issues."]
        pub uBuildVersion: root::AkUInt32,
        #[doc = "Buffer usage (in-place or not). If true, and the plug-in is an insert effect, it should implement IAkInPlaceEffectPlugin, otherwise it should implement IAkOutOfPlaceEffectPlugin. If it is an object processor (see CanProcessObjects, below), it should implement IAkInPlaceObjectPlugin or IAkOutOfPlaceObjectPlugin respectively."]
        pub bIsInPlace: bool,
        #[doc = "True for effects whose sample throughput is different between input and output. Effects that can change rate need to be out-of-place (!bIsInPlace), and cannot exist on busses."]
        pub bCanChangeRate: bool,
        #[doc = "Legacy bIsAsynchronous plug-in flag, now unused. Preserved for plug-in backward compatibility. bReserved should be false for all plug-in."]
        pub bReserved: bool,
        #[doc = "Plug-in can process audio objects. They must implement IAkInPlaceObjectPlugin or IAkOutOfPlaceObjectPlugin, depending on if they work in-place or out-of-place. Out-of-place object processors only work on busses."]
        pub bCanProcessObjects: bool,
        #[doc = "Plug-in can process final mixes and objects right before sending them to the audio device for output. Plug-ins that process the main mix, passthrough mix and objects directly at the end of the pipeline must implement IAkAudioDeviceEffectPlugin. Audio device effect plug-ins must be in place (bIsInPlace = true) and must be able to process objects (bCanProcessObjects = true)."]
        pub bIsDeviceEffect: bool,
        #[doc = "Plug-in can run on bus with Audio Object configuration. Effect plug-ins are instantiated once per Audio Objects on those busses. While this may be fine for effects such as EQs, it is an user error for effects such as reverbs, or for any effect that is non-linear. Effects that return false will fail to initialize when created on busses with Audio Object Configuration."]
        pub bCanRunOnObjectConfig: bool,
        #[doc = "Plug-in knows how to process objects separately from the cumulativeGain of the object (or the processing of the object's audio is independent of the overall object gain). bCanProcessObjects must also be true, as this relies on Object Metadata."]
        pub bUsesGainAttribute: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkAcousticTexture {
        _unused: [u8; 0],
    }
    pub type AkCreatePluginCallback = ::std::option::Option<
        unsafe extern "C" fn(
            in_pAllocator: *mut root::AK::IAkPluginMemAlloc,
        ) -> *mut root::AK::IAkPlugin,
    >;
    pub type AkCreateParamCallback = ::std::option::Option<
        unsafe extern "C" fn(
            in_pAllocator: *mut root::AK::IAkPluginMemAlloc,
        ) -> *mut root::AK::IAkPluginParam,
    >;
    pub type AkGetDeviceListCallback = ::std::option::Option<
        unsafe extern "C" fn(
            io_maxNumDevices: *mut root::AkUInt32,
            out_deviceDescriptions: *mut root::AkDeviceDescription,
        ) -> root::AKRESULT,
    >;
    #[doc = " \\cond !(Web)"]
    #[doc = " Platform specific initialization settings"]
    #[doc = " \\sa AK::SoundEngine::Init"]
    #[doc = " \\sa AK::SoundEngine::GetDefaultPlatformInitSettings"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkPlatformInitSettings {
        #[doc = "Lower engine threading properties"]
        pub threadLEngine: root::AkThreadProperties,
        #[doc = "Ouput thread threading properties"]
        pub threadOutputMgr: root::AkThreadProperties,
        #[doc = "Bank manager threading properties (its default priority is AK_THREAD_PRIORITY_NORMAL)"]
        pub threadBankManager: root::AkThreadProperties,
        #[doc = "Monitor threading properties (its default priority is AK_THREAD_PRIORITY_ABOVENORMAL). This parameter is not used in Release build."]
        pub threadMonitor: root::AkThreadProperties,
        #[doc = "Sampling Rate. Default 48000 Hz"]
        pub uSampleRate: root::AkUInt32,
        #[doc = "Number of refill buffers in voice buffer. 2 == double-buffered, defaults to 4."]
        pub uNumRefillsInVoice: root::AkUInt16,
    }
    pub type AkAssertHook = ::std::option::Option<
        unsafe extern "C" fn(
            in_pszExpression: *const ::std::os::raw::c_char,
            in_pszFileName: *const ::std::os::raw::c_char,
            in_lineNumber: ::std::os::raw::c_int,
        ),
    >;
    #[doc = " Callback function prototype for User Music notifications"]
    #[doc = "\tIt is useful for reacting to user music playback."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - \\ref AkGlobalCallbackFunc"]
    #[doc = " - \\ref AkPlatformInitSettings"]
    #[doc = " - \\ref background_music_and_dvr"]
    #[doc = ""]
    pub type AkBackgroundMusicChangeCallbackFunc = ::std::option::Option<
        unsafe extern "C" fn(
            in_bBackgroundMusicMuted: bool,
            in_pCookie: *mut ::std::os::raw::c_void,
        ) -> root::AKRESULT,
    >;
    #[doc = " Platform-independent initialization settings of output devices."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkOutputSettings {
        #[doc = "Unique ID of a custom audio device to be used. Custom audio devices are defined in the Audio Device Shareset section of the Wwise project."]
        #[doc = "If you want to output normally through the output device defined on the Master Bus in your project, leave this field to its default value (AK_INVALID_UNIQUE_ID, or value 0)."]
        #[doc = "Typical usage: AkInitSettings.eOutputSettings.audioDeviceShareset = AK::SoundEngine::GetIDFromString(\"InsertYourAudioDeviceSharesetNameHere\");"]
        pub audioDeviceShareset: root::AkUniqueID,
        #[doc = "Device specific identifier, when multiple devices of the same type are possible.  If only one device is possible, leave to 0."]
        #[doc = "- PS4 Controller-Speakers: UserID as returned from sceUserServiceGetLoginUserIdList"]
        #[doc = "- XBoxOne Controller-Headphones: Use the AK::GetDeviceID function to get the ID from an IMMDevice. Find the player's device with the WASAPI API (IMMDeviceEnumerator, see Microsoft documentation) or use AK::GetDeviceIDFromName."]
        #[doc = "- Windows: Use AK::GetDeviceID or AK::GetDeviceIDFromName to get the correct ID.  Leave to 0 for the default Windows device as seen in Audio Properties."]
        #[doc = "- All other outputs: use 0 to select the default for the selected audio device type (shareset)"]
        pub idDevice: root::AkUInt32,
        #[doc = "Rule for 3D panning of signals routed to a stereo bus. In AkPanningRule_Speakers mode, the angle of the front loudspeakers"]
        #[doc = "(uSpeakerAngles[0]) is used. In AkPanningRule_Headphones mode, the speaker angles are superseded with constant power panning"]
        #[doc = "between two virtual microphones spaced 180 degrees apart."]
        pub ePanningRule: root::AkPanningRule,
        #[doc = "Channel configuration for this output. Call AkChannelConfig::Clear() to let the engine use the default output configuration."]
        #[doc = "Hardware might not support the selected configuration."]
        pub channelConfig: root::AkChannelConfig,
    }
    extern "C" {
        #[link_name = "\u{1}__ZN16AkOutputSettingsC1EPKcj15AkChannelConfig13AkPanningRule"]
        pub fn AkOutputSettings_AkOutputSettings(
            this: *mut root::AkOutputSettings,
            in_szDeviceShareSet: *const ::std::os::raw::c_char,
            in_idDevice: root::AkUniqueID,
            in_channelConfig: root::AkChannelConfig,
            in_ePanning: root::AkPanningRule,
        );
    }
    extern "C" {
        #[link_name = "\u{1}__ZN16AkOutputSettingsC1EPKwj15AkChannelConfig13AkPanningRule"]
        pub fn AkOutputSettings_AkOutputSettings1(
            this: *mut root::AkOutputSettings,
            in_szDeviceShareSet: *const u32,
            in_idDevice: root::AkUniqueID,
            in_channelConfig: root::AkChannelConfig,
            in_ePanning: root::AkPanningRule,
        );
    }
    impl AkOutputSettings {
        #[inline]
        pub unsafe fn new(
            in_szDeviceShareSet: *const ::std::os::raw::c_char,
            in_idDevice: root::AkUniqueID,
            in_channelConfig: root::AkChannelConfig,
            in_ePanning: root::AkPanningRule,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            AkOutputSettings_AkOutputSettings(
                __bindgen_tmp.as_mut_ptr(),
                in_szDeviceShareSet,
                in_idDevice,
                in_channelConfig,
                in_ePanning,
            );
            __bindgen_tmp.assume_init()
        }
        #[inline]
        pub unsafe fn new1(
            in_szDeviceShareSet: *const u32,
            in_idDevice: root::AkUniqueID,
            in_channelConfig: root::AkChannelConfig,
            in_ePanning: root::AkPanningRule,
        ) -> Self {
            let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
            AkOutputSettings_AkOutputSettings1(
                __bindgen_tmp.as_mut_ptr(),
                in_szDeviceShareSet,
                in_idDevice,
                in_channelConfig,
                in_ePanning,
            );
            __bindgen_tmp.assume_init()
        }
    }
    pub const AkFloorPlane_AkFloorPlane_XZ: root::AkFloorPlane = 0;
    pub const AkFloorPlane_AkFloorPlane_XY: root::AkFloorPlane = 1;
    pub const AkFloorPlane_AkFloorPlane_YZ: root::AkFloorPlane = 2;
    pub const AkFloorPlane_AkFloorPlane_Default: root::AkFloorPlane = 0;
    #[doc = " Possible values for the floor plane axis used in the Game Object 3D Viewer in Wwise"]
    pub type AkFloorPlane = ::std::os::raw::c_uint;
    #[doc = " The execution context for a task."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkTaskContext {
        #[doc = "The current thread index [0, AkTaskSchedulerDesc::uNumSchedulerWorkerThreads[."]
        pub uIdxThread: root::AkUInt32,
    }
    #[doc = " Task function: process the [in_uIdxBegin,in_uIdxEnd[ range of items in the in_pData array."]
    pub type AkParallelForFunc = ::std::option::Option<
        unsafe extern "C" fn(
            in_pData: *mut ::std::os::raw::c_void,
            in_uIdxBegin: root::AkUInt32,
            in_uIdxEnd: root::AkUInt32,
            in_ctx: root::AkTaskContext,
            in_pUserData: *mut ::std::os::raw::c_void,
        ),
    >;
    #[doc = " Description of the client task scheduler."]
    #[repr(C)]
    #[repr(align(8))]
    #[derive(Debug, Copy, Clone)]
    pub struct AkTaskSchedulerDesc {
        pub _bindgen_opaque_blob: [u64; 2usize],
    }
    #[doc = " Execute in_func in parallel over the [in_uIdxBegin,in_uIdxEnd[ range of items in the in_pData array,"]
    #[doc = " and wait for the work to finish."]
    pub type AkTaskSchedulerDesc_ParallelForFunc = ::std::option::Option<
        unsafe extern "C" fn(
            in_pData: *mut ::std::os::raw::c_void,
            in_uIdxBegin: root::AkUInt32,
            in_uIdxEnd: root::AkUInt32,
            in_uTileSize: root::AkUInt32,
            in_func: root::AkParallelForFunc,
            in_pUserData: *mut ::std::os::raw::c_void,
            in_szDebugName: *const ::std::os::raw::c_char,
        ),
    >;
    #[doc = " Platform-independent initialization settings of the sound engine"]
    #[doc = " \\sa"]
    #[doc = " - <tt>AK::SoundEngine::Init()</tt>"]
    #[doc = " - <tt>AK::SoundEngine::GetDefaultInitSettings()</tt>"]
    #[doc = " - \\ref soundengine_integration_init_advanced"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkInitSettings {
        #[doc = "External assertion handling function (optional)"]
        pub pfnAssertHook: root::AkAssertHook,
        #[doc = "Maximum number of paths for positioning"]
        pub uMaxNumPaths: root::AkUInt32,
        #[doc = "Size of the command queue, in bytes"]
        pub uCommandQueueSize: root::AkUInt32,
        #[doc = "Sets to true to enable AK::SoundEngine::PrepareGameSync usage."]
        pub bEnableGameSyncPreparation: bool,
        #[doc = "Number of quanta ahead when continuous containers should instantiate a new voice before which next sounds should start playing. This look-ahead time allows I/O to occur, and is especially useful to reduce the latency of continuous containers with trigger rate or sample-accurate transitions."]
        #[doc = "Default is 1 audio quantum, also known as an audio frame. Its size is equal to AkInitSettings::uNumSamplesPerFrame / AkPlatformInitSettings::uSampleRate. For many platforms the default values - which can be overridden - are respectively 1,024 samples and 48 kHz. This gives a default 21.3 ms for an audio quantum, which is adequate if you have a RAM-based streaming device that completes transfers within 20 ms. With 1 look-ahead quantum, voices spawned by continuous containers are more likely to be ready when they are required to play, thereby improving the overall precision of sound scheduling. If your device completes transfers in 30 ms instead, you might consider increasing this value to 2 because it will grant new voices 2 audio quanta (~43 ms) to fetch data."]
        pub uContinuousPlaybackLookAhead: root::AkUInt32,
        #[doc = "Number of samples per audio frame (256, 512, 1024, or 2048)."]
        pub uNumSamplesPerFrame: root::AkUInt32,
        #[doc = "Size of the monitoring queue, in bytes. This parameter is not used in Release build."]
        pub uMonitorQueuePoolSize: root::AkUInt32,
        #[doc = "Main output device settings."]
        pub settingsMainOutput: root::AkOutputSettings,
        #[doc = "Amount of time to wait for HW devices to trigger an audio interrupt. If there is no interrupt after that time, the sound engine will revert to  silent mode and continue operating until the HW finally comes back. Default value: 2000 (2 seconds)"]
        pub uMaxHardwareTimeoutMs: root::AkUInt32,
        #[doc = "Use a separate thread for loading sound banks. Allows asynchronous operations."]
        pub bUseSoundBankMgrThread: bool,
        #[doc = "Use a separate thread for processing audio. If set to false, audio processing will occur in RenderAudio(). \\ref goingfurther_eventmgrthread"]
        pub bUseLEngineThread: bool,
        #[doc = "Application-defined audio source change event callback function."]
        pub BGMCallback: root::AkBackgroundMusicChangeCallbackFunc,
        #[doc = "Application-defined user data for the audio source change event callback function."]
        pub BGMCallbackCookie: *mut ::std::os::raw::c_void,
        #[doc = "When using DLLs for plugins, specify their path. Leave NULL if DLLs are in the same folder as the game executable."]
        pub szPluginDLLPath: *mut root::AkOSChar,
        #[doc = "Floor plane axis for 3D game object viewing."]
        pub eFloorPlane: root::AkFloorPlane,
        #[doc = "The number of game units in a meter."]
        pub fGameUnitsToMeters: root::AkReal32,
        #[doc = "The defined client task scheduler that AkSoundEngine will use to schedule internal tasks."]
        pub taskSchedulerDesc: root::AkTaskSchedulerDesc,
        #[doc = "The number of bytes read by the BankReader when new data needs to be loaded from disk during serialization. Increasing this trades memory usage for larger, but fewer, file-read events during bank loading."]
        pub uBankReadBufferSize: root::AkUInt32,
        #[doc = "Debug setting: Only used when bDebugOutOfRangeCheckEnabled is true.  This defines the maximum values samples can have.  Normal audio must be contained within +1/-1.  This limit should be set higher to allow temporary or short excursions out of range.  Default is 16."]
        pub fDebugOutOfRangeLimit: root::AkReal32,
        #[doc = "Debug setting: Enable checks for out-of-range (and NAN) floats in the processing code.  This incurs a small performance hit, but can be enabled in most scenarios.  Will print error messages in the log if invalid values are found at various point in the pipeline. Contact AK Support with the new error messages for more information."]
        pub bDebugOutOfRangeCheckEnabled: bool,
    }
    #[doc = " Necessary settings for setting externally-loaded sources"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkSourceSettings {
        #[doc = "Source ID (available in the SoundBank content files)"]
        pub sourceID: root::AkUniqueID,
        #[doc = "Pointer to the data to be set for the source"]
        pub pMediaMemory: *mut root::AkUInt8,
        #[doc = "Size, in bytes, of the data to be set for the source"]
        pub uMediaSize: root::AkUInt32,
    }
    #[doc = " Return values for GetSourcePlayPositions."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkSourcePosition {
        #[doc = "Audio Node ID of playing item"]
        pub audioNodeID: root::AkUniqueID,
        #[doc = "Media ID of playing item. (corresponds to 'ID' attribute of 'File' element in SoundBank metadata file)"]
        pub mediaID: root::AkUniqueID,
        #[doc = "Position of the source (in ms) associated with that playing item"]
        pub msTime: root::AkTimeMs,
        #[doc = "Position of the source (in samples) associated with that playing item"]
        pub samplePosition: root::AkUInt32,
        #[doc = "Value of GetBufferTick() at the time the position was updated"]
        pub updateBufferTick: root::AkUInt32,
    }
    #[doc = " Positioning information obtained from an object"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkPositioningInfo {
        #[doc = "Center % [0..1]"]
        pub fCenterPct: root::AkReal32,
        #[doc = "Speaker panning type: type of panning logic when object is not 3D spatialized."]
        pub pannerType: root::AkSpeakerPanningType,
        #[doc = "3D position type: defines what acts as the emitter position for computing spatialization against the listener."]
        pub e3dPositioningType: root::Ak3DPositionType,
        #[doc = "Hold emitter position and orientation values when starting playback."]
        pub bHoldEmitterPosAndOrient: bool,
        #[doc = "Spatialization mode"]
        pub e3DSpatializationMode: root::Ak3DSpatializationMode,
        #[doc = "Attenuation parameter set is active."]
        pub bEnableAttenuation: bool,
        #[doc = "Use the cone attenuation"]
        pub bUseConeAttenuation: bool,
        #[doc = "Inner angle"]
        pub fInnerAngle: root::AkReal32,
        #[doc = "Outer angle"]
        pub fOuterAngle: root::AkReal32,
        #[doc = "Cone max attenuation"]
        pub fConeMaxAttenuation: root::AkReal32,
        #[doc = "Cone low pass filter value"]
        pub LPFCone: root::AkLPFType,
        #[doc = "Cone low pass filter value"]
        pub HPFCone: root::AkLPFType,
        #[doc = "Maximum distance"]
        pub fMaxDistance: root::AkReal32,
        #[doc = "Volume dry at maximum distance"]
        pub fVolDryAtMaxDist: root::AkReal32,
        #[doc = "Volume wet at maximum distance (if any) (based on the Game defined distance attenuation)"]
        pub fVolAuxGameDefAtMaxDist: root::AkReal32,
        #[doc = "Volume wet at maximum distance (if any) (based on the User defined distance attenuation)"]
        pub fVolAuxUserDefAtMaxDist: root::AkReal32,
        #[doc = "Low pass filter value at max distance (if any)"]
        pub LPFValueAtMaxDist: root::AkLPFType,
        #[doc = "High pass filter value at max distance (if any)"]
        pub HPFValueAtMaxDist: root::AkLPFType,
    }
    #[doc = " Object information structure for QueryAudioObjectsIDs"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkObjectInfo {
        #[doc = "Object ID"]
        pub objID: root::AkUniqueID,
        #[doc = "Object ID of the parent"]
        pub parentID: root::AkUniqueID,
        #[doc = "Depth in tree"]
        pub iDepth: root::AkInt32,
    }
    pub type AkMemInitForThread = ::std::option::Option<unsafe extern "C" fn()>;
    pub type AkMemTermForThread = ::std::option::Option<unsafe extern "C" fn()>;
    pub type AkMemMalloc = ::std::option::Option<
        unsafe extern "C" fn(
            poolId: root::AkMemPoolId,
            uSize: root::size_t,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type AkMemMalign = ::std::option::Option<
        unsafe extern "C" fn(
            poolId: root::AkMemPoolId,
            uSize: root::size_t,
            uAlignment: root::AkUInt32,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type AkMemRealloc = ::std::option::Option<
        unsafe extern "C" fn(
            poolId: root::AkMemPoolId,
            pAddress: *mut ::std::os::raw::c_void,
            uSize: root::size_t,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type AkMemReallocAligned = ::std::option::Option<
        unsafe extern "C" fn(
            poolId: root::AkMemPoolId,
            pAddress: *mut ::std::os::raw::c_void,
            uSize: root::size_t,
            uAlignment: root::AkUInt32,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type AkMemFree = ::std::option::Option<
        unsafe extern "C" fn(poolId: root::AkMemPoolId, pAddress: *mut ::std::os::raw::c_void),
    >;
    pub type AkMemTotalReservedMemorySize =
        ::std::option::Option<unsafe extern "C" fn() -> root::size_t>;
    pub type AkMemSizeOfMemory = ::std::option::Option<
        unsafe extern "C" fn(
            poolId: root::AkMemPoolId,
            pAddress: *mut ::std::os::raw::c_void,
        ) -> root::size_t,
    >;
    pub type AkMemDebugMalloc = ::std::option::Option<
        unsafe extern "C" fn(
            poolId: root::AkMemPoolId,
            uSize: root::size_t,
            pAddress: *mut ::std::os::raw::c_void,
            pszFile: *const ::std::os::raw::c_char,
            uLine: root::AkUInt32,
        ),
    >;
    pub type AkMemDebugMalign = ::std::option::Option<
        unsafe extern "C" fn(
            poolId: root::AkMemPoolId,
            uSize: root::size_t,
            uAlignment: root::AkUInt32,
            pAddress: *mut ::std::os::raw::c_void,
            pszFile: *const ::std::os::raw::c_char,
            uLine: root::AkUInt32,
        ),
    >;
    pub type AkMemDebugRealloc = ::std::option::Option<
        unsafe extern "C" fn(
            poolId: root::AkMemPoolId,
            pOldAddress: *mut ::std::os::raw::c_void,
            uSize: root::size_t,
            pNewAddress: *mut ::std::os::raw::c_void,
            pszFile: *const ::std::os::raw::c_char,
            uLine: root::AkUInt32,
        ),
    >;
    pub type AkMemDebugReallocAligned = ::std::option::Option<
        unsafe extern "C" fn(
            poolId: root::AkMemPoolId,
            pOldAddress: *mut ::std::os::raw::c_void,
            uSize: root::size_t,
            uAlignment: root::AkUInt32,
            pNewAddress: *mut ::std::os::raw::c_void,
            pszFile: *const ::std::os::raw::c_char,
            uLine: root::AkUInt32,
        ),
    >;
    pub type AkMemDebugFree = ::std::option::Option<
        unsafe extern "C" fn(poolId: root::AkMemPoolId, pAddress: *mut ::std::os::raw::c_void),
    >;
    pub type AkMemAllocVM = ::std::option::Option<
        unsafe extern "C" fn(
            size: root::size_t,
            extra: *mut root::size_t,
        ) -> *mut ::std::os::raw::c_void,
    >;
    pub type AkMemFreeVM = ::std::option::Option<
        unsafe extern "C" fn(
            address: *mut ::std::os::raw::c_void,
            size: root::size_t,
            extra: root::size_t,
            release: root::size_t,
        ),
    >;
    #[doc = " Initialization settings for the default implementation of the Memory Manager. For more details, see \\ref memorymanager_init."]
    #[doc = " \\sa AK::MemoryMgr"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMemSettings {
        #[doc = "(Optional) Thread-specific allocator initialization hook."]
        pub pfInitForThread: root::AkMemInitForThread,
        #[doc = "(Optional) Thread-specific allocator termination hook."]
        pub pfTermForThread: root::AkMemTermForThread,
        #[doc = "(Optional) Memory allocation hook."]
        pub pfMalloc: root::AkMemMalloc,
        #[doc = "(Optional) Memory allocation hook."]
        pub pfMalign: root::AkMemMalign,
        #[doc = "(Optional) Memory allocation hook."]
        pub pfRealloc: root::AkMemRealloc,
        #[doc = "(Optional) Memory allocation hook."]
        pub pfReallocAligned: root::AkMemReallocAligned,
        #[doc = "(Optional) Memory allocation hook."]
        pub pfFree: root::AkMemFree,
        #[doc = "(Optional) Memory allocation statistics hook."]
        pub pfTotalReservedMemorySize: root::AkMemTotalReservedMemorySize,
        #[doc = "(Optional) Memory allocation statistics hook."]
        pub pfSizeOfMemory: root::AkMemSizeOfMemory,
        #[doc = "When non-zero, limits the total amount of virtual and device memory allocated by AK::MemoryMgr."]
        pub uMemAllocationSizeLimit: root::AkUInt64,
        #[doc = "Virtual page allocation hook."]
        pub pfAllocVM: root::AkMemAllocVM,
        #[doc = "Virtual page allocation hook."]
        pub pfFreeVM: root::AkMemFreeVM,
        #[doc = "Device page allocation hook."]
        pub pfAllocDevice: root::AkMemAllocVM,
        #[doc = "Device page allocation hook."]
        pub pfFreeDevice: root::AkMemFreeVM,
        #[doc = "Virtual memory page size. Defaults to 0 which means auto-detect."]
        pub uVMPageSize: root::AkUInt32,
        #[doc = "Device memory page size. Defaults to 0 which means auto-detect."]
        pub uDevicePageSize: root::AkUInt32,
        #[doc = "(Optional) Memory allocation debugging hook. Used for tracking calls to pfMalloc."]
        pub pfDebugMalloc: root::AkMemDebugMalloc,
        #[doc = "(Optional) Memory allocation debugging hook. Used for tracking calls to pfMalign."]
        pub pfDebugMalign: root::AkMemDebugMalign,
        #[doc = "(Optional) Memory allocation debugging hook. Used for tracking calls to pfRealloc."]
        pub pfDebugRealloc: root::AkMemDebugRealloc,
        #[doc = "(Optional) Memory allocation debugging hook. Used for tracking calls to pfReallocAligned."]
        pub pfDebugReallocAligned: root::AkMemDebugReallocAligned,
        #[doc = "(Optional) Memory allocation debugging hook. Used for tracking calls to pfFree."]
        pub pfDebugFree: root::AkMemDebugFree,
        #[doc = "Default 0 disabled. 1 debug enabled. 2 stomp allocator enabled. 3 stomp allocator and debug enabled. User implementations may use multiple non-zero values to offer different features."]
        pub uMemoryDebugLevel: root::AkUInt32,
    }
    #[doc = "The stream is idle"]
    pub const AkStmStatus_AK_StmStatusIdle: root::AkStmStatus = 0;
    #[doc = "Operation completed / Automatic stream reached end"]
    pub const AkStmStatus_AK_StmStatusCompleted: root::AkStmStatus = 1;
    #[doc = "Operation pending / The stream is waiting for I/O"]
    pub const AkStmStatus_AK_StmStatusPending: root::AkStmStatus = 2;
    #[doc = "Operation cancelled"]
    pub const AkStmStatus_AK_StmStatusCancelled: root::AkStmStatus = 3;
    #[doc = "The low-level I/O reported an error"]
    pub const AkStmStatus_AK_StmStatusError: root::AkStmStatus = 4;
    #[doc = " Stream status."]
    pub type AkStmStatus = ::std::os::raw::c_uint;
    #[doc = "Move offset from the start of the stream"]
    pub const AkMoveMethod_AK_MoveBegin: root::AkMoveMethod = 0;
    #[doc = "Move offset from the current stream position"]
    pub const AkMoveMethod_AK_MoveCurrent: root::AkMoveMethod = 1;
    #[doc = "Move offset from the end of the stream"]
    pub const AkMoveMethod_AK_MoveEnd: root::AkMoveMethod = 2;
    #[doc = " Move method for position change."]
    #[doc = " \\sa"]
    #[doc = " - AK::IAkStdStream::SetPosition()"]
    #[doc = " - AK::IAkAutoStream::SetPosition()"]
    pub type AkMoveMethod = ::std::os::raw::c_uint;
    #[doc = "Read-only access"]
    pub const AkOpenMode_AK_OpenModeRead: root::AkOpenMode = 0;
    #[doc = "Write-only access (opens the file if it already exists)"]
    pub const AkOpenMode_AK_OpenModeWrite: root::AkOpenMode = 1;
    #[doc = "Write-only access (deletes the file if it already exists)"]
    pub const AkOpenMode_AK_OpenModeWriteOvrwr: root::AkOpenMode = 2;
    #[doc = "Read and write access"]
    pub const AkOpenMode_AK_OpenModeReadWrite: root::AkOpenMode = 3;
    #[doc = " File open mode."]
    pub type AkOpenMode = ::std::os::raw::c_uint;
    #[doc = " File system flags for file descriptors mapping."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkFileSystemFlags {
        #[doc = "Company ID (Wwise uses AKCOMPANYID_AUDIOKINETIC, defined in AkTypes.h, for soundbanks and standard streaming files, and AKCOMPANYID_AUDIOKINETIC_EXTERNAL for streaming external sources)."]
        pub uCompanyID: root::AkUInt32,
        #[doc = "File/codec type ID (defined in AkTypes.h)"]
        pub uCodecID: root::AkUInt32,
        #[doc = "Size of the custom parameter"]
        pub uCustomParamSize: root::AkUInt32,
        #[doc = "Custom parameter"]
        pub pCustomParam: *mut ::std::os::raw::c_void,
        #[doc = "True when the file location depends on language"]
        pub bIsLanguageSpecific: bool,
        #[doc = "True when the file is opened to be used as an automatic stream. Note that you don't need to set it."]
        #[doc = "If you pass an AkFileSystemFlags to IAkStreamMgr CreateStd|Auto(), it will be set internally to the correct value."]
        pub bIsAutomaticStream: bool,
        #[doc = "Cache ID for caching system used by automatic streams. The user is responsible for guaranteeing unicity of IDs."]
        #[doc = "When set, it supersedes the file ID passed to AK::IAkStreamMgr::CreateAuto() (ID version). Caching is optional and depends on the implementation."]
        pub uCacheID: root::AkFileID,
        #[doc = "Indicates the number of bytes from the beginning of the file that should be streamed into cache via a caching stream. This field is only relevant when opening caching streams via"]
        #[doc = "AK::IAkStreamMgr::PinFileInCache() and AK::SoundEngine::PinEventInStreamCache().  When using AK::SoundEngine::PinEventInStreamCache(),"]
        #[doc = "it is initialized to the prefetch size stored in the sound bank, but may be changed by the file location resolver, or set to 0 to cancel caching."]
        pub uNumBytesPrefetch: root::AkUInt32,
    }
    #[doc = " Stream information."]
    #[doc = " \\sa"]
    #[doc = " - AK::IAkStdStream::GetInfo()"]
    #[doc = " - AK::IAkAutoStream::GetInfo()"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkStreamInfo {
        #[doc = "Device ID"]
        pub deviceID: root::AkDeviceID,
        #[doc = "User-defined stream name (specified through AK::IAkStdStream::SetStreamName() or AK::IAkAutoStream::SetStreamName())"]
        pub pszName: *const root::AkOSChar,
        #[doc = "Total stream/file size in bytes"]
        pub uSize: root::AkUInt64,
        #[doc = "True when the file is open (implementations may defer file opening)"]
        pub bIsOpen: bool,
    }
    #[doc = " Automatic streams heuristics."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkAutoStmHeuristics {
        #[doc = "Average throughput in bytes/ms"]
        pub fThroughput: root::AkReal32,
        #[doc = "Set to the start of loop (byte offset from the beginning of the stream) for streams that loop, 0 otherwise"]
        pub uLoopStart: root::AkUInt32,
        #[doc = "Set to the end of loop (byte offset from the beginning of the stream) for streams that loop, 0 otherwise"]
        pub uLoopEnd: root::AkUInt32,
        #[doc = "Minimum number of buffers if you plan to own more than one buffer at a time, 0 or 1 otherwise"]
        #[doc = "\\remarks You should always release buffers as fast as possible, therefore this heuristic should be used only when"]
        #[doc = "dealing with special contraints, like drivers or hardware that require more than one buffer at a time.\\n"]
        #[doc = "Also, this is only a heuristic: it does not guarantee that data will be ready when calling AK::IAkAutoStream::GetBuffer()."]
        pub uMinNumBuffers: root::AkUInt8,
        #[doc = "The stream priority. it should be between AK_MIN_PRIORITY and AK_MAX_PRIORITY (included)."]
        pub priority: root::AkPriority,
    }
    #[doc = " Automatic streams buffer settings/constraints."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkAutoStmBufSettings {
        #[doc = "Hard user constraint: When non-zero, forces the I/O buffer to be of size uBufferSize"]
        #[doc = "(overriding the device's granularity)."]
        #[doc = "Otherwise, the size is determined by the device's granularity."]
        pub uBufferSize: root::AkUInt32,
        #[doc = "Soft user constraint: When non-zero, specifies a minimum buffer size"]
        #[doc = "\\remarks Ignored if uBufferSize is specified."]
        pub uMinBufferSize: root::AkUInt32,
        #[doc = "Hard user constraint: When non-zero, buffer size will be a multiple of that number, and returned addresses will always be aligned on multiples of this value."]
        pub uBlockSize: root::AkUInt32,
    }
    #[doc = " Device descriptor."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkDeviceDesc {
        #[doc = "Device ID"]
        pub deviceID: root::AkDeviceID,
        #[doc = "Specifies whether or not the device is writable"]
        pub bCanWrite: bool,
        #[doc = "Specifies whether or not the device is readable"]
        pub bCanRead: bool,
        #[doc = "Device name"]
        pub szDeviceName: [root::AkUtf16; 16usize],
        #[doc = "Device name string's size (number of characters)"]
        pub uStringSize: root::AkUInt32,
    }
    #[doc = " Device descriptor."]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkDeviceData {
        #[doc = "Device ID"]
        pub deviceID: root::AkDeviceID,
        #[doc = "IO memory pool size"]
        pub uMemSize: root::AkUInt32,
        #[doc = "IO memory pool used"]
        pub uMemUsed: root::AkUInt32,
        #[doc = "Cumulative number of allocations"]
        pub uAllocs: root::AkUInt32,
        #[doc = "Cumulative number of deallocations"]
        pub uFrees: root::AkUInt32,
        #[doc = "Memory peak since monitoring started"]
        pub uPeakRefdMemUsed: root::AkUInt32,
        #[doc = "IO memory that is cached but is not currently used for active streams."]
        pub uUnreferencedCachedBytes: root::AkUInt32,
        #[doc = "IO memory pool block size"]
        pub uGranularity: root::AkUInt32,
        #[doc = "Number of streams that have been active in the previous frame"]
        pub uNumActiveStreams: root::AkUInt32,
        #[doc = "Number of bytes transferred, including cached transfers"]
        pub uTotalBytesTransferred: root::AkUInt32,
        #[doc = "Number of bytes transferred exclusively via low-level"]
        pub uLowLevelBytesTransferred: root::AkUInt32,
        #[doc = "Total bytes from cache as a percentage of total bytes."]
        pub fAvgCacheEfficiency: root::AkReal32,
        #[doc = "Number of low-level transfers that have completed in the previous monitoring frame"]
        pub uNumLowLevelRequestsCompleted: root::AkUInt32,
        #[doc = "Number of low-level transfers that were cancelled in the previous monitoring frame"]
        pub uNumLowLevelRequestsCancelled: root::AkUInt32,
        #[doc = "Number of low-level transfers that are currently pending"]
        pub uNumLowLevelRequestsPending: root::AkUInt32,
        #[doc = "Custom number queried from low-level IO."]
        pub uCustomParam: root::AkUInt32,
        #[doc = "Number of bytes that can be pinned into cache."]
        pub uCachePinnedBytes: root::AkUInt32,
    }
    #[doc = " Stream general information."]
    #[repr(C, packed(4))]
    #[derive(Debug, Copy, Clone)]
    pub struct AkStreamRecord {
        #[doc = "Unique stream identifier"]
        pub uStreamID: root::AkUInt32,
        #[doc = "Device ID"]
        pub deviceID: root::AkDeviceID,
        #[doc = "Stream name"]
        pub szStreamName: [root::AkUtf16; 64usize],
        #[doc = "Stream name string's size (number of characters)"]
        pub uStringSize: root::AkUInt32,
        #[doc = "File size"]
        pub uFileSize: root::AkUInt64,
        #[doc = "File descriptor's uCustomParamSize"]
        pub uCustomParamSize: root::AkUInt32,
        #[doc = "File descriptor's pCustomParam (on 32 bits)"]
        pub uCustomParam: root::AkUInt32,
        #[doc = "True for auto streams"]
        pub bIsAutoStream: bool,
        #[doc = "True for caching streams"]
        pub bIsCachingStream: bool,
    }
    #[doc = " Stream statistics."]
    #[repr(C, packed(4))]
    #[derive(Debug, Copy, Clone)]
    pub struct AkStreamData {
        #[doc = "Unique stream identifier"]
        pub uStreamID: root::AkUInt32,
        #[doc = "Stream priority"]
        pub uPriority: root::AkUInt32,
        #[doc = "Current position"]
        pub uFilePosition: root::AkUInt64,
        #[doc = "Total stream buffer size (specific to IAkAutoStream)"]
        pub uTargetBufferingSize: root::AkUInt32,
        #[doc = "Size of available data including requested data (specific to IAkAutoStream)"]
        pub uVirtualBufferingSize: root::AkUInt32,
        #[doc = "Size of available data (specific to IAkAutoStream)"]
        pub uBufferedSize: root::AkUInt32,
        #[doc = "Transfered amount since last query (Accumulate/Reset)"]
        pub uNumBytesTransfered: root::AkUInt32,
        #[doc = "Transfered amount (from low-level IO only) since last query (Accumulate/Reset)"]
        pub uNumBytesTransferedLowLevel: root::AkUInt32,
        #[doc = "Amount of streaming memory referenced by this stream"]
        pub uMemoryReferenced: root::AkUInt32,
        #[doc = "Estimated throughput heuristic"]
        pub fEstimatedThroughput: root::AkReal32,
        #[doc = "True if this stream has been active (that is, was ready for I/O or had at least one pending I/O transfer, uncached or not) in the previous frame"]
        pub bActive: bool,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct CAkFilePackage {
        _unused: [u8; 0],
    }
    #[doc = " Stream Manager initialization settings."]
    #[doc = " \\sa"]
    #[doc = " - AK::IAkStreamMgr"]
    #[doc = " - AK::StreamMgr::Create()"]
    #[doc = " - \\ref streamingmanager_settings"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkStreamMgrSettings {
        pub _address: u8,
    }
    #[doc = " High-level IO devices initialization settings."]
    #[doc = " \\sa"]
    #[doc = " - AK::IAkStreamMgr"]
    #[doc = " - AK::StreamMgr::CreateDevice()"]
    #[doc = " - \\ref streamingmanager_settings"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkDeviceSettings {
        #[doc = "Pointer for I/O memory allocated by user."]
        #[doc = "Pass NULL if you want memory to be allocated via AK::MemoryMgr::Malign()."]
        #[doc = "If specified, uIOMemorySize, uIOMemoryAlignment and ePoolAttributes are ignored."]
        pub pIOMemory: *mut ::std::os::raw::c_void,
        #[doc = "Size of memory for I/O (for automatic streams). It is passed directly to AK::MemoryMgr::Malign(), after having been rounded down to a multiple of uGranularity."]
        pub uIOMemorySize: root::AkUInt32,
        #[doc = "I/O memory alignment. It is passed directly to AK::MemoryMgr::Malign()."]
        pub uIOMemoryAlignment: root::AkUInt32,
        #[doc = "Attributes for I/O memory. Here, specify the allocation type (AkMemType_Device, and so on). It is passed directly to AK::MemoryMgr::Malign()."]
        pub ePoolAttributes: root::AkUInt32,
        #[doc = "I/O requests granularity (typical bytes/request)."]
        pub uGranularity: root::AkUInt32,
        #[doc = "Scheduler type flags."]
        pub uSchedulerTypeFlags: root::AkUInt32,
        #[doc = "Scheduler thread properties."]
        pub threadProperties: root::AkThreadProperties,
        #[doc = "Targetted automatic stream buffer length (ms). When a stream reaches that buffering, it stops being scheduled for I/O except if the scheduler is idle."]
        pub fTargetAutoStmBufferLength: root::AkReal32,
        #[doc = "Maximum number of transfers that can be sent simultaneously to the Low-Level I/O (applies to AK_SCHEDULER_DEFERRED_LINED_UP device only)."]
        pub uMaxConcurrentIO: root::AkUInt32,
        #[doc = "If true the device attempts to reuse IO buffers that have already been streamed from disk. This is particularly useful when streaming small looping sounds. The drawback is a small CPU hit when allocating memory, and a slightly larger memory footprint in the StreamManager pool."]
        pub bUseStreamCache: bool,
        #[doc = "Maximum number of bytes that can be \"pinned\" using AK::SoundEngine::PinEventInStreamCache() or AK::IAkStreamMgr::PinFileInCache()"]
        pub uMaxCachePinnedBytes: root::AkUInt32,
    }
    #[doc = " File descriptor. File identification for the low-level I/O."]
    #[doc = " \\sa"]
    #[doc = " - AK::StreamMgr::IAkLowLevelIOHook"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkFileDesc {
        #[doc = "File size in bytes"]
        pub iFileSize: root::AkInt64,
        #[doc = "Start sector (the sector size is specified by the low-level I/O)"]
        #[doc = "\\sa"]
        #[doc = "- AK::StreamMgr::IAkFileLocationResolver::Open()"]
        #[doc = "- AK::StreamMgr::IAkLowLevelIOHook::GetBlockSize()"]
        pub uSector: root::AkUInt64,
        #[doc = "Size of the custom parameter"]
        pub uCustomParamSize: root::AkUInt32,
        #[doc = "Custom parameter"]
        pub pCustomParam: *mut ::std::os::raw::c_void,
        #[doc = "File handle/identifier"]
        pub hFile: root::AkFileHandle,
        #[doc = "Device ID, obtained from CreateDevice() \\sa AK::IAkStreamMgr::CreateDevice()"]
        pub deviceID: root::AkDeviceID,
        #[doc = "If this file is in a File Package, this will be the"]
        pub pPackage: *mut root::CAkFilePackage,
    }
    #[doc = " Structure for synchronous transfers handshaking with the Low-Level I/O. Used with blocking I/O hooks."]
    #[doc = " \\sa AK::StreamMgr::IAkIOHookBlocking"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkIOTransferInfo {
        #[doc = "File offset where transfer should begin."]
        pub uFilePosition: root::AkUInt64,
        #[doc = "Size of the buffer in which the I/O hook can write to."]
        pub uBufferSize: root::AkUInt32,
        #[doc = "Exact number of requested bytes for this transfer. Always equal to or smaller than uBufferSize."]
        pub uRequestedSize: root::AkUInt32,
    }
    pub type AkIOCallback = ::std::option::Option<
        unsafe extern "C" fn(
            in_pTransferInfo: *mut root::AkAsyncIOTransferInfo,
            in_eResult: root::AKRESULT,
        ),
    >;
    pub type AkBatchIOCallback = ::std::option::Option<
        unsafe extern "C" fn(
            in_uNumTransfers: root::AkUInt32,
            in_ppTransferInfo: *mut *mut root::AkAsyncIOTransferInfo,
            in_peResult: *mut root::AKRESULT,
        ),
    >;
    #[doc = " Structure for asynchronous transfers handshaking with the Low-Level I/O. Extends AkIOTransferInfo."]
    #[doc = " \\sa"]
    #[doc = " - AK::StreamMgr::IAkIOHookDeferredBatch"]
    #[doc = " - AkIOTransferInfo"]
    #[doc = " - AkAIOCallback"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkAsyncIOTransferInfo {
        pub _base: root::AkIOTransferInfo,
        #[doc = "Buffer for data transfer."]
        pub pBuffer: *mut ::std::os::raw::c_void,
        #[doc = "Callback function used to notify the high-level device when the transfer is complete."]
        pub pCallback: root::AkIOCallback,
        #[doc = "Reserved. The I/O device uses this cookie to retrieve the owner of the transfer."]
        pub pCookie: *mut ::std::os::raw::c_void,
        #[doc = "Custom user data."]
        pub pUserData: *mut ::std::os::raw::c_void,
    }
    #[doc = " Low-Level I/O requests heuristics."]
    #[doc = " Used for asynchronous read requests."]
    #[doc = " \\sa"]
    #[doc = " - AK::StreamMgr::IAkIOHookBlocking::Read()"]
    #[doc = " - AK::StreamMgr::IAkIOHookBlocking::Write()"]
    #[doc = " - AK::StreamMgr::IAkIOHookDeferredBatch::Read()"]
    #[doc = " - AK::StreamMgr::IAkIOHookDeferredBatch::Write()"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkIoHeuristics {
        #[doc = "Operation deadline (ms)."]
        pub fDeadline: root::AkReal32,
        #[doc = "Operation priority (at the time it was scheduled and sent to the Low-Level I/O). Range is [AK_MIN_PRIORITY,AK_MAX_PRIORITY], inclusively."]
        pub priority: root::AkPriority,
    }
    #[doc = " Platform-independent initialization settings of the music engine"]
    #[doc = " \\sa"]
    #[doc = " - AK::MusicEngine::Init()"]
    #[doc = " - \\ref soundengine_integration_init_advanced"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkMusicSettings {
        #[doc = "Multiplication factor for all streaming look-ahead heuristic values."]
        pub fStreamingLookAheadRatio: root::AkReal32,
    }
    #[doc = " Platform-independent initialization settings of communication module between the Wwise sound engine"]
    #[doc = " and authoring tool."]
    #[doc = " \\sa"]
    #[doc = " - AK::Comm::Init()"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkCommSettings {
        #[doc = " Ports used for communication between the Wwise authoring application and your game."]
        #[doc = " \\sa"]
        #[doc = " - \\ref initialization_comm"]
        #[doc = " - AkCommSettings::Ports"]
        #[doc = " - AK::Comm::Init()"]
        pub ports: root::AkCommSettings_Ports,
        #[doc = " Select the device of the communication system."]
        #[doc = " By default, connecting to the Authoring tool"]
        #[doc = " \\sa"]
        #[doc = " - \\ref initialization_comm"]
        #[doc = " - AkCommSettings::AkCommSystem"]
        #[doc = " - AK::Comm::Init()"]
        pub commSystem: root::AkCommSettings_AkCommSystem,
        #[doc = " Tells if the base console communication library should be initialized."]
        #[doc = " If set to false, the game should load/initialize the console's communication library prior to calling this function."]
        #[doc = " Set to false only if your game already use sockets before the sound engine initialization."]
        #[doc = " Some consoles have critical requirements for initialization, see \\ref initialization_comm_console_lib"]
        pub bInitSystemLib: bool,
        #[doc = " Optional name that will be displayed over network remote connection of Wwise."]
        #[doc = " It must be a NULL terminated string."]
        pub szAppNetworkName: [::std::os::raw::c_char; 64usize],
    }
    #[doc = " Ports used for communication between the Wwise authoring application and your game."]
    #[doc = " All of these ports are opened in the game when Wwise communication is enabled."]
    #[doc = " When using HIO type communication, the ports are in fact channels and they must be 3"]
    #[doc = " consecutives channels in the order they are defined in the Port structure."]
    #[doc = ""]
    #[doc = " \\sa"]
    #[doc = " - \\ref initialization_comm_ports"]
    #[doc = " - AK::Comm::GetDefaultInitSettings()"]
    #[doc = " - AK::Comm::Init()"]
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct AkCommSettings_Ports {
        #[doc = " This is where the authoring application broadcasts \"Game Discovery\" requests"]
        #[doc = " to discover games running on the network. Default value: 24024."]
        #[doc = ""]
        #[doc = " \\warning Unlike the other ports in this structure, this port cannot be dynamic"]
        #[doc = "          (cannot be set to 0). Refer to \\ref initialization_comm_ports_discovery_broadcast"]
        #[doc = "          for more details."]
        pub uDiscoveryBroadcast: root::AkUInt16,
        #[doc = " Used by the \"command\" channel."]
        #[doc = " \\remark Set to 0 to request a dynamic/ephemeral port."]
        pub uCommand: root::AkUInt16,
        #[doc = " Used by the \"notification\" channel."]
        #[doc = " \\remark Set to 0 to request a dynamic/ephemeral port."]
        pub uNotification: root::AkUInt16,
    }
    pub const AkCommSettings_AkCommSystem_AkCommSystem_Socket: root::AkCommSettings_AkCommSystem =
        0;
    #[doc = " The recommended default communication system"]
    pub const AkCommSettings_AkCommSystem_AkCommSystem_HTCS: root::AkCommSettings_AkCommSystem = 1;
    #[doc = " Allows selecting the communication system used to connect remotely the Authoring tool on the device."]
    pub type AkCommSettings_AkCommSystem = ::std::os::raw::c_uint;
    extern "C" {
        #[link_name = "\u{1}__Z20InitDefaultStreamMgrRK16AkDeviceSettingsPKc"]
        pub fn InitDefaultStreamMgr(
            deviceSettings: *const root::AkDeviceSettings,
            basePath: *const root::AkOSChar,
        ) -> root::AKRESULT;
    }
    extern "C" {
        #[link_name = "\u{1}__Z20TermDefaultStreamMgrv"]
        pub fn TermDefaultStreamMgr();
    }
}
